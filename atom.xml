<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sqjuanke</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-26T08:17:50.878Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IM构建 01 网络基础建设</title>
    <link href="http://yoursite.com/2019/11/26/im-01/"/>
    <id>http://yoursite.com/2019/11/26/im-01/</id>
    <published>2019-11-26T07:59:57.000Z</published>
    <updated>2020-11-26T08:17:50.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="socket基本知识"><a href="#socket基本知识" class="headerlink" title="socket基本知识"></a>socket基本知识</h1><ul><li>socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址</li><li>创建socket连接时，可以配置不同传输协议，支持TCP/UDP</li><li>在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息</li><li>上面一点需要注意，尽管一旦建立连接后可以持续发送消息，但是在实际情况下，有多种因素导致断开，比如网关，防火墙等等因素，所以需要借助心跳包，来“监听”网络是否断开</li><li>使用Socket无需设置ATS</li></ul><a id="more"></a><p>socket流程图：</p><p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcYgENEyfYmnejfrOnSCPSq2u5ywusHSU7o2Oa0iLmK7cD32gz4e5m09rgY*6IfwtXTPLmw*RaVKUDKvVLR5aKJk!/r" alt=""></p><h2 id="1、GCD控制网络调用"><a href="#1、GCD控制网络调用" class="headerlink" title="1、GCD控制网络调用"></a>1、GCD控制网络调用</h2><p>使用GCD控制连接、心跳包的操作，只需要dispatch_suspend即可停止操作</p><ul><li>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，因网关、防火墙等导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init &#123;</span><br><span class="line"></span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">        self.connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">        dispatch_source_set_event_handler(self.connectTimer, ^&#123;</span><br><span class="line">            //进行连接</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        self.heartbeatTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">        dispatch_source_set_event_handler(self.heartbeatTimer, ^&#123;</span><br><span class="line">            //心跳包发送</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>发起连接操作：对于连接操作，无需重复操作，对于心跳则使用延后，定时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t w = dispatch_walltime(NULL, 0);</span><br><span class="line">dispatch_source_set_timer(self.connectTimer, w, DISPATCH_TIME_FOREVER, 0);</span><br><span class="line">dispatch_resume(self.connectTimer);</span><br><span class="line">    </span><br><span class="line">w = dispatch_walltime(NULL, self.heartTime);</span><br><span class="line">dispatch_source_set_timer(self.heartTime, w, self.heartTime*NSEC_PER_SEC, self.heartTime*NSEC_PER_SEC/2);</span><br><span class="line">dispatch_resume(self.heartbeatTimer);</span><br></pre></td></tr></table></figure><h2 id="2、连接过程"><a href="#2、连接过程" class="headerlink" title="2、连接过程"></a>2、连接过程</h2><p>基于socket连接，设置SQTCP实例类</p><p><strong>addrinfo 结构体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct addrinfo &#123;</span><br><span class="line">    int ai_flags;        </span><br><span class="line">    int ai_family;        </span><br><span class="line">    int ai_socktype;    </span><br><span class="line">    int ai_protocol;                </span><br><span class="line">    size_t ai_addrlen;              //指向缓冲区的字节数</span><br><span class="line">    char* ai_canonname;             //主机的规范化名称</span><br><span class="line">    struct sockaddr* ai_addr;       //指向sockaddr结构的指针。getaddrinfo返回的每个addrinfo结构内的ai_addr都指向一个filled-in套接字地址结构。</span><br><span class="line">    struct addrinfo* ai_next;       //指向链表中下一个addrinfo结构的指针，如果是链表的最后一个addrinfo结构，则ai_next为NULL。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>取值</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>ai_family</td><td>AF_INET</td><td>2</td><td>IPv4</td></tr><tr><td></td><td>AF_INET6</td><td>23</td><td>IPv6</td></tr><tr><td></td><td>AF_UNSPEC</td><td>0</td><td>协议无关</td></tr><tr><td>ai_protocol</td><td>IPPROTO_IP</td><td>0</td><td>IP协议</td></tr><tr><td></td><td>IPPROTO_IPV4</td><td>4</td><td>IPv4</td></tr><tr><td></td><td>IPPROTO_IPV6</td><td>41</td><td>IPv6</td></tr><tr><td></td><td>IPPROTO_UDP</td><td>17</td><td>UDP</td></tr><tr><td></td><td>IPPROTO_TCP</td><td>6</td><td>TCP</td></tr><tr><td>ai_socktype</td><td>SOCK_STREAM</td><td>1</td><td>流 (默认协议是TCP)</td></tr><tr><td></td><td>SOCK_DGRAM</td><td>2</td><td>数据报(默认协议是UDP)</td></tr><tr><td>ai_flags</td><td>AI_PASSIVE</td><td>1</td><td>被动的，用于bind，通常用于server socket</td></tr><tr><td></td><td>AI_CANONNAME</td><td>2</td><td>IPv4</td></tr><tr><td></td><td>AI_NUMERICHOST</td><td>4</td><td>地址为数字串</td></tr></tbody></table><p>ai_flags 说明：<br>ai_flags的值范围为0~7，取决于程序如何设置3个标志位，比如设置ai_flags为 “AI_PASSIVE|AI_CANONNAME”，ai_flags值就为3。三个参数的含义分别为：</p><ul><li>AI_PASSIVE当此标志置位时，表示调用者将在bind()函数调用中使用返回的地址结构。当此标志不置位时，表示将在connect()函数调用中使用。当节点名位NULL，且此标志置位，则返回的地址将是通配地址。如果节点名NULL，且此标志不置位，则返回的地址将是回环地址。</li><li>AI_CANNONAME当此标志置位时，在函数所返回的第一个addrinfo结构中的ai_cannoname成员中，应该包含一个以空字符结尾的字符串，字符串的内容是节点名的正规名。</li><li>AI_NUMERICHOST当此标志置位时，此标志表示调用中的节点名必须是一个数字地址字符串。</li></ul><p><strong>getaddrinfo 函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result )</span><br></pre></td></tr></table></figure></p><p>getaddrinfo：函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个sockaddr 结构的链而不是一个地址清单。它具有协议无关性。</p><ul><li>hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)</li><li>service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等</li><li>hints：可以是一个空指针，也可以是一个指向某个addrinfo结构的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。</li><li>返回0： 成功，返回非0： 出错。</li></ul><p><strong>connect</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)connect:(NSString*)host port:(int)port completionBlock:(SQConnectCompletionBlock)completionBlock &#123;</span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in6 addr;</span><br><span class="line">    struct addrinfo addrinfo;</span><br><span class="line">    </span><br><span class="line">    BOOL res = [self _synthesizeIPv6:host port:port addr:(struct sockaddr*)&amp;addr addrinfo:&amp;addrinfo];</span><br><span class="line">    if (!res) &#123;</span><br><span class="line">        NSLog(@&quot;synthesize ipv6 fail&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int r;</span><br><span class="line">    int sockfd;</span><br><span class="line">    </span><br><span class="line">    // socket()函数用于根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所用的资源。如果协议protocol未指定(等于0), 则使用缺省的连接方式。</span><br><span class="line">    sockfd = socket(addrinfo.ai_family, addrinfo.ai_socktype, addrinfo.ai_protocol);</span><br><span class="line">    sock_nonblock(sockfd, 1);</span><br><span class="line">    </span><br><span class="line">    int value = 1;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;value, sizeof(value));</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (addrinfo.ai_family == AF_INET) &#123;</span><br><span class="line">        </span><br><span class="line">            // 用于建立与指定socket的连接.</span><br><span class="line">            // 客户端socket</span><br><span class="line">            // 指向数据结构sockaddr的指针，其中包括目的端口和IP地址服务器的&quot;结构体&quot;地址</span><br><span class="line">            // 结构体数据长度</span><br><span class="line">    </span><br><span class="line">            r = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(struct sockaddr_in));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //ipv6</span><br><span class="line">            r = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(struct sockaddr_in6));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (r == -1 &amp;&amp; errno == EINTR);</span><br><span class="line">    if (r == -1) &#123;</span><br><span class="line">        if (errno != EINPROGRESS) &#123;</span><br><span class="line">            close(sockfd);</span><br><span class="line">            NSLog(@&quot;connect error:%s&quot;, strerror(errno));</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    self.writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, sockfd, 0, queue);</span><br><span class="line">    __weak SQTCP *wself = self;</span><br><span class="line">    dispatch_source_set_event_handler(self.writeSource, ^&#123;</span><br><span class="line">        [wself _onWrite];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_resume(self.writeSource);</span><br><span class="line">    self.sock = sockfd;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)_synthesizeIPv6:(NSString*)host port:(int)port addr:(struct sockaddr*)addr addrinfo:(struct addrinfo*)info &#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct addrinfo hints, *res0, *res;</span><br><span class="line">    const char *ipv4_str = [host UTF8String];</span><br><span class="line">    </span><br><span class="line">    memset(&amp;hints, 0, sizeof(hints));</span><br><span class="line">    hints.ai_family = PF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_DEFAULT;</span><br><span class="line">    </span><br><span class="line">    error = getaddrinfo(ipv4_str, &quot;&quot;, &amp;hints, &amp;res0);</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;, gai_strerror(error));</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (res = res0; res; res = res-&gt;ai_next) &#123;</span><br><span class="line">        NSLog(@&quot;family:%d socktype;%d protocol:%d&quot;, res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL r = YES;</span><br><span class="line"></span><br><span class="line">    if (res0) &#123;</span><br><span class="line">        if (res0-&gt;ai_family == AF_INET6) &#123;</span><br><span class="line">            struct sockaddr_in6 *addr6 = ((struct sockaddr_in6*)res0-&gt;ai_addr);</span><br><span class="line">            addr6-&gt;sin6_port = htons(port);</span><br><span class="line">            </span><br><span class="line">            memcpy(addr, res0-&gt;ai_addr, res0-&gt;ai_addrlen);</span><br><span class="line">            *info = *res0;</span><br><span class="line">        &#125; else if (res0-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">            struct sockaddr_in *addr4 = ((struct sockaddr_in*)res0-&gt;ai_addr);</span><br><span class="line">            addr4-&gt;sin_port = htons(port);</span><br><span class="line">            </span><br><span class="line">            memcpy(addr, res0-&gt;ai_addr, res0-&gt;ai_addrlen);</span><br><span class="line">            *info = *res0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(res0);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>write</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)write:(NSData*)data &#123;</span><br><span class="line">    [self.data appendData:data];</span><br><span class="line">    if (!self.writeSourceActive &amp;&amp; self.writeSource) &#123;</span><br><span class="line">        dispatch_resume(self.writeSource);</span><br><span class="line">        self.writeSourceActive = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)_onWrite &#123;</span><br><span class="line">    </span><br><span class="line">    const char *p = [self.data bytes];</span><br><span class="line">    int n = write_data(self.sock, (uint8_t*)p, (int)self.data.length);</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        NSLog(@&quot;sock write error:%d&quot;, errno);</span><br><span class="line">        dispatch_suspend(self.writeSource);</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.data = [NSMutableData dataWithBytes:p+n length:self.data.length - n];</span><br><span class="line">    if (self.data.length == 0) &#123;</span><br><span class="line">        dispatch_suspend(self.writeSource);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int write_data(int fd, uint8_t *bytes, int len) &#123;</span><br><span class="line">    ssize_t n = 0;</span><br><span class="line">     </span><br><span class="line">    do &#123;</span><br><span class="line">    </span><br><span class="line">     // 客户端socket</span><br><span class="line">     // 发送内容地址 void * == id</span><br><span class="line">     // 发送内容长度</span><br><span class="line">     // 发送方式标志，一般为0</span><br><span class="line">    </span><br><span class="line">        n = send(fd, bytes, len, 0);</span><br><span class="line">    &#125; while(n == -1 &amp;&amp; errno == EINTR);</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (int)n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>read</strong></p><ul><li>服务器返回的数据不一定会一次全部返完，所以我们需要循环接收数据，当返回数据为0时结束</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)startRead:(SQReadCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    self.readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, self.sock, 0, queue);</span><br><span class="line">    __weak SQTCP *wself = self;</span><br><span class="line">    dispatch_source_set_event_handler(self.readSource, ^&#123;</span><br><span class="line">        [wself onRead];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(self.readSource);</span><br><span class="line">    self.readSourceActive = YES;</span><br><span class="line">    self.readCompletionBlock = completionBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-(void)onRead &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        ssize_t nread;</span><br><span class="line">        char buf[BUF_SIZE];</span><br><span class="line">        </span><br><span class="line">        do &#123;</span><br><span class="line">        </span><br><span class="line">        // 客户端socket</span><br><span class="line">        // 接收内容缓冲区地址</span><br><span class="line">        // 接收内容缓存区长度</span><br><span class="line">        </span><br><span class="line">            nread = read(self.sock, buf, BUF_SIZE);</span><br><span class="line">        &#125;while (nread &lt; 0 &amp;&amp; errno == EINTR);</span><br><span class="line">        </span><br><span class="line">        if (nread &lt; 0) &#123;</span><br><span class="line">            if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self.readCompletionBlock(self, nil, errno);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (nread == 0) &#123;</span><br><span class="line">            self.readCompletionBlock(self, nil, 0);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSData *data = [NSData dataWithBytes:buf length:nread];</span><br><span class="line">            self.readCompletionBlock(self, data, 0);</span><br><span class="line">            if (nread &lt; BUF_SIZE) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>close</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-(void)close &#123;</span><br><span class="line">    __block int count = 0;</span><br><span class="line">    </span><br><span class="line">    void (^on_cancel)() = ^&#123;</span><br><span class="line">        --count;</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            NSLog(@&quot;async tcp closed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (self.writeSource) count++;</span><br><span class="line">    if (self.readSource) count++;</span><br><span class="line">    if (self.writeSource) &#123;</span><br><span class="line">        NSLog(@&quot;cancel write source&quot;);</span><br><span class="line">        if (!self.writeSourceActive) &#123;</span><br><span class="line">            dispatch_resume(self.writeSource);</span><br><span class="line">            self.writeSourceActive = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_source_set_cancel_handler(self.writeSource, on_cancel);</span><br><span class="line">        dispatch_source_cancel(self.writeSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.readSource) &#123;</span><br><span class="line">        NSLog(@&quot;cancel read source&quot;);</span><br><span class="line">        if (!self.readSourceActive) &#123;</span><br><span class="line">            dispatch_resume(self.readSource);</span><br><span class="line">            self.readSourceActive = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_source_set_cancel_handler(self.readSource, on_cancel);</span><br><span class="line">        dispatch_source_cancel(self.readSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.sock != -1) &#123;</span><br><span class="line">        NSLog(@&quot;close socket&quot;);</span><br><span class="line">        close(self.sock);</span><br><span class="line">        self.sock = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;socket基本知识&quot;&gt;&lt;a href=&quot;#socket基本知识&quot; class=&quot;headerlink&quot; title=&quot;socket基本知识&quot;&gt;&lt;/a&gt;socket基本知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址&lt;/li&gt;
&lt;li&gt;创建socket连接时，可以配置不同传输协议，支持TCP/UDP&lt;/li&gt;
&lt;li&gt;在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息&lt;/li&gt;
&lt;li&gt;上面一点需要注意，尽管一旦建立连接后可以持续发送消息，但是在实际情况下，有多种因素导致断开，比如网关，防火墙等等因素，所以需要借助心跳包，来“监听”网络是否断开&lt;/li&gt;
&lt;li&gt;使用Socket无需设置ATS&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="IM" scheme="http://yoursite.com/tags/IM/"/>
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES2.0 – iphone开发指引 下</title>
    <link href="http://yoursite.com/2018/10/29/tutorial-for-ios-getting-started-with-opengl-es-02/"/>
    <id>http://yoursite.com/2018/10/29/tutorial-for-ios-getting-started-with-opengl-es-02/</id>
    <published>2018-10-29T06:51:46.000Z</published>
    <updated>2020-10-28T07:39:06.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这个系列教程中，我们的目标是帮助大家揭开OpenGL ES 2.0的神秘面纱，同时给大家提供一个手把手的例子，能带领大家步入OpenGL ES 2.0的开发世界。</p></blockquote><p>在第一部分教程中，我们介绍了基本的初始化OpenGL，创建简单的顶点和片断shaders，并且在屏幕上面画了一个简单的旋转立方体。</p><p>在这部分教程中，我们将步入更高的级别，给立方体进行纹理贴图！</p><a id="more"></a><p>声明：我并不是一个Open GL的专家，所有这些知识都是我自学来的，这篇教程是我在学习的过程中写的。如果我不小心犯了一些很煞笔的错误，欢迎大家可以给我指正！（译者：当然，其实我也是刚学了一点OpenGL的知识，如果翻译有问题，也肯请大牛帮助指正）</p><p>好了，让我们一起进入纹理贴图的世界吧！</p><h1 id="一、开始吧"><a href="#一、开始吧" class="headerlink" title="一、开始吧"></a>一、开始吧</h1><p>如果你还没有上一篇教程的工程的话，你可以从这里先下载样例工程。</p><p>下载完后，编译并运行工程，你将会看到一个旋转的立方体：</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619100850.jpg?raw=true" alt=""></p><p>现在，我们的立方体看起来是红绿相间的，因为我们指定顶点的颜色就是这么做的—还没有使用任何纹理贴图。</p><p>但是，不用担心—这正是本教程接下来要做的事！</p><p>首先，下载本教程所需要使用的<a href="https://github.com/sqjuanke/learnopengl/raw/master/resource/file/OpenGL2TextureTutResources.zip" target="_blank" rel="noopener">纹理图片</a>，下载完后解压之。然后把它们拖到Resource分组中，同时确保 “Copy items into destination group’s folder” 被选中，然后点击Finish。</p><p>你会看到，新添加了两张图片—一张看起来像地板砖，另一张看起来像条鱼。我们将把立方体的每一个面都贴上这个地板砖。</p><h2 id="读取像素数据"><a href="#读取像素数据" class="headerlink" title="读取像素数据"></a>读取像素数据</h2><p>我们的第一步就是把图片数据读取到OpenGL中来。</p><p>这里有个问题，就是OpenGL不能直接使用png图片数据，而是，你首先获得png图片的像素数据buffer，并且你需要为这些数据指定格式。</p><p>幸运的是，你可以轻松地使用Quartz2D的函数来得到图片的像素数据buffer。如果你看过Core Graphics 101系列教程的话，你肯定对下面的调用很熟悉了。</p><p>要完全读取像素buffer的工作，你需要以下4步：</p><ol><li>获得Core Graphics 图片引用. 因为我们将使用Core Graphics来读取原始的像素数据，所以我们首先要取得图片的引用（reference）。这其实很简单，UIImage有一个CGImageRef属性。</li><li>创建Core Graphics位图context. 接下来就是创建Core Graphics位图context，context是内存中的缓冲区，是一种非常方便的方式来保存原始像素。</li><li>在context中绘制Image.  我们可以使用Core Graphics的一个简单的函数调用来搞定这个事—-然后context里面会包含原始图片数据。</li><li>把原始像素数据发送给OpenGL.  为了实现这个，我们首先要创建一个OpenGL 纹理对象，然后获得它的唯一的ID（叫做“name”），然后使用一个函数调用把像素数据发送给OpenGL。</li></ol><p>好了，让我们看看具体代码是怎么写的吧。打开OpenGLView.m，然后在initWithFrame方法上面添加下面的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (GLuint)setupTexture:(NSString *)fileName &#123;    </span><br><span class="line">    // 1</span><br><span class="line">    CGImageRef spriteImage = [UIImage imageNamed:fileName].CGImage;</span><br><span class="line">    if (!spriteImage) &#123;</span><br><span class="line">        NSLog(@&quot;Failed to load image %@&quot;, fileName);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 2</span><br><span class="line">    size_t width = CGImageGetWidth(spriteImage);</span><br><span class="line">    size_t height = CGImageGetHeight(spriteImage);</span><br><span class="line"> </span><br><span class="line">    GLubyte * spriteData = (GLubyte *) calloc(width*height*4, sizeof(GLubyte));</span><br><span class="line"> </span><br><span class="line">    CGContextRef spriteContext = CGBitmapContextCreate(spriteData, width, height, 8, width*4, </span><br><span class="line">        CGImageGetColorSpace(spriteImage), kCGImageAlphaPremultipliedLast);    </span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    CGContextDrawImage(spriteContext, CGRectMake(0, 0, width, height), spriteImage);</span><br><span class="line"> </span><br><span class="line">    CGContextRelease(spriteContext);</span><br><span class="line"> </span><br><span class="line">    // 4</span><br><span class="line">    GLuint texName;</span><br><span class="line">    glGenTextures(1, &amp;texName);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texName);</span><br><span class="line"> </span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); </span><br><span class="line"> </span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, spriteData);</span><br><span class="line"> </span><br><span class="line">    free(spriteData);        </span><br><span class="line">    return texName;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有许多代码，让我们一段一段来看：　</p><p>1) 获得Core Graphics 图片引用. 从上面的代码可以看出，其实灰常简单。我们使用UIImage imageNamed：方法初始化一个UIImage对象，然后获得它的CGImage属性即可。</p><p>2) 创建Core Graphics位图上下文. 为了创建位图上下文，你将不得不手动分配内存空间。这里我们使用image的函数来得到宽度和高度，然后分配 width<em>height</em>4个字节的数据空间。</p><p>”为什么要乘以4？“你可能会问。当我们调用方法来绘制图片数据的时候，我们要为red，green，blue和alpha通道，每一个通道准备一个字节，所以就要乘以4.</p><p>“为什么要为每一个通道准备一个字节？”你可能又会问。好吧，因为我们将使用Core Graphics来建立绘图上下文。而CGBitmapContextCreate函数里面的第4个参数指定的就是每一个通道要采用几位来表现，我们使用8位，所以是一个字节。</p><p>3) 把图片数据绘制到context中. 这也是一个非常简单的操作—我们只需要告诉Core Graphics在一个指定的矩形区域内来绘制这些图像即可。因为我们完成了绘制图片的工作，所以用完要release。</p><p>4) 把像素数据发送给OpenGL. 我们首先调用 glGenTextures来创建一个纹理对象，并且得到一个唯一的ID，由“name”保存着。然后，我们调用glBindTexture来把我们新建的纹理名字加载到当前的纹理单元中。接下来的步骤是，为我们的纹理设置纹理参数，使用glTexParameteri函数。这里我们设置函数参数为GL_TEXTURE_MIN_FILTER（这个参数的意思是，当我们绘制远距离的对象的时候，我们会把纹理缩小）和GL_NEAREST（这个参数的作用是，当绘制顶点的时候，选择最邻近的纹理像素）。</p><p>另一种非常简单的思考方式是，把GL_NEAREST看作是“pixel art-like”，而GL_LINEAR是“平滑”。</p><p>注意：虽然本例子中没有使用mipmaps，但是，还是需要设置GL_TEXTURE_MIN_FILTER。我刚开始不知道要这样做，而且并没有设置这个参数，结果屏幕上什么也看不到！后来我在OpenGL 常见错误中发现在这个问题–走运啊！</p><p>最后一步就是把像素buffer中的数据发送给OpenGL，通过调用函数glTexImage2D。当你调用这个函数的时候，你需要指定像素格式。这里我们指定的是GL_RGBA和GL_UNSIGNED_BYTE。它的意思是说，红绿蓝alpha道具都有，并且他们占用的空间是1个字节，也就是每一个通道8位。</p><p>OpenGL还支持其它的像素格式（你也可以查一查cocos2d支持的像素格式有哪些）。但是，对于本教程来说，我们就只使用这种RGBA了，其它的留给读者自己去探究。</p><p>一旦我们把图片数据发送给OpenGL之后，我们就可以释放掉像素buffer了—我们不再需要它了，因为Opengl已经把纹理存储到GPU中去了。最后，我们返回纹理的名字，这个名字我们之后的程序要使用到。</p><h3 id="使用纹理数据"><a href="#使用纹理数据" class="headerlink" title="使用纹理数据"></a>使用纹理数据</h3><p>现在，我们拥有一个辅助方法来加载图片并能够把它发送给OpenGL了。接下来，让我们使用这个给立方体做件“嫁衣”吧！</p><p>我们将从顶点和片断着色器开始。打开 SimpleVertex.glsl，然后替换成下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 Position; </span><br><span class="line">attribute vec4 SourceColor; </span><br><span class="line"> </span><br><span class="line">varying vec4 DestinationColor; </span><br><span class="line"> </span><br><span class="line">uniform mat4 Projection;</span><br><span class="line">uniform mat4 Modelview;</span><br><span class="line"> </span><br><span class="line">attribute vec2 TexCoordIn; // New</span><br><span class="line">varying vec2 TexCoordOut; // New</span><br><span class="line"> </span><br><span class="line">void main(void) &#123; </span><br><span class="line">    DestinationColor = SourceColor; </span><br><span class="line">    gl_Position = Projection * Modelview * Position;</span><br><span class="line">    TexCoordOut = TexCoordIn; // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们声明了一个新的属性，叫做TexCoordIn。记住，属性就是一个值，你可以把它赋值给每一个顶点。因此，对于每一个顶点，我们为它指定需要映射的纹理坐标。</p><p>纹理坐标看起来有点奇怪，它们的取值范围总是0-1.因此（0，0）就代表纹理的左下角，而（1，1）则代表纹理的右上角。</p><p>但是，CoreGraphics在加载图片的时候会垂直翻转图片。所以，在代码中（0，1）是左下角，而（0，0）是左上角，够奇怪了吧！</p><p>我们也创建一个新的varying，叫做TexCoordOut，并且把TexCoordIn赋值给它。记住，一个varying也是一个值，OpenGL在进行片断着色的时候会为我们自动进行运算，得到正确的坐标点。因此，打个比方，如果我们把一个正方形的左下角映射纹理坐标为（0，0），而把右上角映射为（1，0）。如果我们在渲染左下角和右上角中间的某个像素的时候，片断着色器会自动计算得到（0.5，0）。</p><p>接下来，替换掉SimpleFragment.glsl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">varying lowp vec4 DestinationColor;</span><br><span class="line"> </span><br><span class="line">varying lowp vec2 TexCoordOut; // New</span><br><span class="line">uniform sampler2D Texture; // New</span><br><span class="line"> </span><br><span class="line">void main(void) &#123;</span><br><span class="line">    gl_FragColor = DestinationColor * texture2D(Texture, TexCoordOut); // New</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们老是把目标色直接赋值给输出色–现在，我们把这个目标色乘以纹理图片中相应的坐标点处的颜色。texture2D是Opengl内置的一个函数，它可以得到一个纹理。　　</p><p>现在，我们新的shaders准备就绪了，让我们来使用它们吧！打开OpenGLView.h，然后添加下面几个实例变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLuint _floorTexture;</span><br><span class="line">GLuint _fishTexture;</span><br><span class="line">GLuint _texCoordSlot;</span><br><span class="line">GLuint _textureUniform;</span><br></pre></td></tr></table></figure><p>这些变量来用保存我们之前添加进来的两张图片的纹理名字，同时声明了新的输入属性槽（input attribute slot）和一个新的纹理统一槽（new texture uniform slot）。　　</p><p>然后打开OpenGLView.m，并作如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Add texture coordinates to Vertex structure as follows</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    float Position[3];</span><br><span class="line">    float Color[4];</span><br><span class="line">    float TexCoord[2]; // New</span><br><span class="line">&#125; Vertex;</span><br><span class="line"> </span><br><span class="line">// Add texture coordinates to Vertices as follows</span><br><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;, &#123;1, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;1, 0, 0, 1&#125;, &#123;1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;, &#123;0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 1, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, -1, -1&#125;, &#123;1, 0, 0, 1&#125;, &#123;1, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, -1&#125;, &#123;1, 0, 0, 1&#125;, &#123;1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -1&#125;, &#123;0, 1, 0, 1&#125;, &#123;0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, -1&#125;, &#123;0, 1, 0, 1&#125;, &#123;0, 0&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// Add to end of compileShaders</span><br><span class="line">_texCoordSlot = glGetAttribLocation(programHandle, &quot;TexCoordIn&quot;);</span><br><span class="line">glEnableVertexAttribArray(_texCoordSlot);</span><br><span class="line">_textureUniform = glGetUniformLocation(programHandle, &quot;Texture&quot;);</span><br><span class="line"> </span><br><span class="line">// Add to end of initWithFrame</span><br><span class="line">_floorTexture = [self setupTexture:@&quot;tile_floor.png&quot;];</span><br><span class="line">_fishTexture = [self setupTexture:@&quot;item_powerup_fish.png&quot;];</span><br><span class="line"> </span><br><span class="line">// Add inside render:, right before glDrawElements</span><br><span class="line">glVertexAttribPointer(_texCoordSlot, 2, GL_FLOAT, GL_FALSE, </span><br><span class="line">    sizeof(Vertex), (GLvoid*) (sizeof(float) *7));    </span><br><span class="line"> </span><br><span class="line">glActiveTexture(GL_TEXTURE0); </span><br><span class="line">glBindTexture(GL_TEXTURE_2D, _floorTexture);</span><br><span class="line">glUniform1i(_textureUniform, 0);</span><br></pre></td></tr></table></figure><p>基于我们前面教程中所介绍的内容，这里的大部分内容应该非常容易理解。</p><p>这里唯一值得详细指出来的就是最后3行代码。这也是我们如何把之前在片断着色器中定义的Texture uiniform映射到我们代码中的texture中来的。　　</p><p>首先，我们激活我们想要加载进入的纹理单元。在IOS上面，我们可以拥有至少2个纹理单元，最多是8个。当我们一次需要对不止一个纹理进行计算的时候，这个就发挥作用了。然后，在本教程中，我们并不需要多于一个的纹理单元，所以我们只需要第一个纹理单元（GL_TEXTURE0）。</p><p>然后，我们把纹理绑定到当前的纹理单元中(GL_TEXTURE0)。最后，把纹理单元0的索引设置为_textureUniform。</p><p>注意：其实第1和3句调用其实并不是必须的，有时候，你可能会看见别人的代码里面可能并没有包含这几行代码。这是因为我们假设GL_TEXTURE0就是当前激活的纹理单元了，我们也不需要设置uniform，因为它默认就是0.我在这篇教程中添加这3行代码的意思是方便初学者更好地理解代码。</p><p>编译并运行代码，这时你可以看到一个拥有纹理贴图的立方体啦！</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619135333.jpg?raw=true" alt=""></p><p>恩。。。这个立方体的正面看起来还算ok，但是其它面看起来有点被拉伸了—这是怎么回事呢？</p><h3 id="修复拉伸效果"><a href="#修复拉伸效果" class="headerlink" title="修复拉伸效果"></a>修复拉伸效果</h3><p>这个问题的原因是，因为我们当前只是为每一个顶点设置一个纹理坐标，然后重复使用这些顶点。</p><p>举个例子，我们把第一面的左下角映射到（0，0）。但是，在左边那一面，同样的顶点数据却变成了右上角，所以这时候如果使用（0，0）纹理坐标去贴图的话就没有意义了，这时候应该要使用（1，0）。（为什么不是（1，1），因为图片垂直翻转了！！！）</p><p>在OpenGL里面，你不能简单的把一个顶点当成是一个顶点坐标—而应该是把坐标、颜色和纹理坐标绑定到一起，统一属于某一个顶点。</p><p>继续并把你的顶点和索引数组替换成下面的内容，它为每一面都定义了顶点坐标、颜色和纹理坐标数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#define TEX_COORD_MAX   1</span><br><span class="line"> </span><br><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    // Front</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    // Back</span><br><span class="line">    &#123;&#123;1, 1, -2&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, -2&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, -1, -2&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -2&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    // Left</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;, </span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -2&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, -2&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    // Right</span><br><span class="line">    &#123;&#123;1, -1, -2&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, -2&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    // Top</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, -2&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -2&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    // Bottom</span><br><span class="line">    &#123;&#123;1, -1, -2&#125;, &#123;1, 0, 0, 1&#125;, &#123;TEX_COORD_MAX, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;0, 1, 0, 1&#125;, &#123;TEX_COORD_MAX, TEX_COORD_MAX&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 0, 1, 1&#125;, &#123;0, TEX_COORD_MAX&#125;&#125;, </span><br><span class="line">    &#123;&#123;-1, -1, -2&#125;, &#123;0, 0, 0, 1&#125;, &#123;0, 0&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const GLubyte Indices[] = &#123;</span><br><span class="line">    // Front</span><br><span class="line">0, 1, 2,</span><br><span class="line">    2, 3, 0,</span><br><span class="line">    // Back</span><br><span class="line">4, 5, 6,</span><br><span class="line">    4, 5, 7,</span><br><span class="line">    // Left</span><br><span class="line">8, 9, 10,</span><br><span class="line">    10, 11, 8,</span><br><span class="line">    // Right</span><br><span class="line">12, 13, 14,</span><br><span class="line">    14, 15, 12,</span><br><span class="line">    // Top</span><br><span class="line">16, 17, 18,</span><br><span class="line">    18, 19, 16,</span><br><span class="line">    // Bottom</span><br><span class="line">20, 21, 22,</span><br><span class="line">    22, 23, 20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就和上一篇教程一样，我首先在纸上把这些数据先用笔标记出来，然后再写代码记录下来—读者最好亲自动手实践一下，这是一个很好的机会！！！　　</p><p>注意，我们这一次重复了很多数据。我现在还没有找到一种更好的方式来做这件事，希望有牛人可以指出来，大家一起学习一下：）</p><p>编译并运行，这时我们有一个看起来更漂亮的立方体啦！</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619144548.jpg?raw=true" alt=""></p><h3 id="重复纹理"><a href="#重复纹理" class="headerlink" title="重复纹理"></a>重复纹理</h3><p>在OpenGL里面，如果你喜欢的话，你可以把一张图片重复地贴在某一个表面上。但是，保证重复纹理时能够拼接得很好，我们需要一些无缝纹理。</p><p>有了纹理之后，我们在OpenGLView.m里面定义下面的宏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TEX_COORD_MAX   4</span><br></pre></td></tr></table></figure><p>因此，现在，我们给立方体每一个表面从左下角（0，0）到右上角（4，4）都映射了纹理贴图。　　</p><p>当映射纹理坐标的时候，它的行为看起来好像是1的模—比如，如果你的纹理坐标是1.5，那么映射的纹理坐标就会是0.5.</p><p>编译并运行，现在你可以看到立方体上有非常好看的重复纹理啦。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619152874.jpg?raw=true" alt=""></p><p>注意: 这个能够工作的原因是因为GL_TEXTURE_WRAP_S 和GL_TEXTURE_WRAP_T 默认值是GL_REPEAT 。如果你不想让纹理这样子重复的知，你可以调用函数glTexParameteri来覆盖默认的行为。</p><h3 id="添加花样"><a href="#添加花样" class="headerlink" title="添加花样"></a>添加花样</h3><p>我们将以在立方体的某一个面添加一个鱼骨头的纹理作为教程的结束。为什么呢？因为Grand Cat Dispatch 要上场啦！</p><p>实现这个功能的步骤可能和本教程前面部分差不了太多。所以，让我们直接开始吧。</p><p>打开OpenGLView.h，然后添加下面几个实例变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLuint _vertexBuffer;</span><br><span class="line">GLuint _indexBuffer;</span><br><span class="line">GLuint _vertexBuffer2;</span><br><span class="line">GLuint _indexBuffer2;</span><br></pre></td></tr></table></figure><p>之前，我们只有一个顶点buffer和一个索引buffer，因此，我们需要再创建它们。现在我们需要2个顶点/索引buffer，就如同上面所定义的一样。</p><p>打开OpenGLView.m，然后做下面的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 1) Add to top of file</span><br><span class="line">const Vertex Vertices2[] = &#123;</span><br><span class="line">    &#123;&#123;0.5, -0.5, 0.01&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;0.5, 0.5, 0.01&#125;, &#123;1, 1, 1, 1&#125;, &#123;1, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;-0.5, 0.5, 0.01&#125;, &#123;1, 1, 1, 1&#125;, &#123;0, 0&#125;&#125;,</span><br><span class="line">    &#123;&#123;-0.5, -0.5, 0.01&#125;, &#123;1, 1, 1, 1&#125;, &#123;0, 1&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const GLubyte Indices2[] = &#123;</span><br><span class="line">    1, 0, 2, 3</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 2) Replace setupVBOs with the following</span><br><span class="line">- (void)setupVBOs &#123;</span><br><span class="line"> </span><br><span class="line">    glGenBuffers(1, &amp;_vertexBuffer);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">    glGenBuffers(1, &amp;_indexBuffer);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">    glGenBuffers(1, &amp;_vertexBuffer2);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer2);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices2), Vertices2, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">    glGenBuffers(1, &amp;_indexBuffer2);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer2);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices2), Indices2, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 3) Add inside render:, right after call to glViewport</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer);</span><br><span class="line"> </span><br><span class="line">// 4) Add to bottom of render:, right before [_context presentRenderbuffer:...]</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, _vertexBuffer2);</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, _indexBuffer2);</span><br><span class="line"> </span><br><span class="line">glActiveTexture(GL_TEXTURE0); </span><br><span class="line">glBindTexture(GL_TEXTURE_2D, _fishTexture);</span><br><span class="line">glUniform1i(_textureUniform, 0); </span><br><span class="line"> </span><br><span class="line">glUniformMatrix4fv(_modelViewUniform, 1, 0, modelView.glMatrix);</span><br><span class="line"> </span><br><span class="line">glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);</span><br><span class="line">glVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*) (sizeof(float) *3));</span><br><span class="line">glVertexAttribPointer(_texCoordSlot, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (GLvoid*) (sizeof(float) *7));</span><br><span class="line"> </span><br><span class="line">glDrawElements(GL_TRIANGLE_STRIP, sizeof(Indices2)/sizeof(Indices2[0]), GL_UNSIGNED_BYTE, 0);</span><br></pre></td></tr></table></figure><p>在第一部分中，我们为矩形定义了一组顶点，我们将在这些顶点所在的范围内绘制鱼骨的纹理。注意，我把它弄得比前表面要稍微小一点，同时，我也把z坐标弄得稍微大一点。这样子我们就会有深度视觉效果了。　　</p><p>在第二部分中，我们保存顶点/索引 buffer。我们也以鱼骨矩形区域创建第一个顶点/索引buffer。</p><p>在第三部分中，我们在绘制纹理之前先绑定顶点/索引buffer。</p><p>在第四部分中，我们绑定鱼矩形区域的顶点/索引buffer，加载鱼的纹理，然后设置所有的属性。注意，这里我们绘制三角形使用一种新的模式–GL_TRIANGLE_STRIP。</p><p>GL_TRIANGLE_STRIP会生成三角形带，具体的解释可以参考《如何使用cocos2d制作一个tiny wings游戏》。使用这个参数可以减少索引buffer的大小。</p><p>编译并运行，然后你会看到下面的输出。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619163159.jpg?raw=true" alt=""></p><p>这里绘制了鱼的图片，但是，渲染的效果并不是很好。为了使之效果更好看，我们需要激活blend，在渲染函数里面添加下面2行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">glEnable(GL_BLEND);</span><br></pre></td></tr></table></figure><p>第一行使用glBlendFunc 来设置混合算法。设置源为GL_ONE的意思是渲染所有的源图像的像素，而GL_ONE_MINS_SRC_ALPHA意思是渲染所有的目标图像数据，但是源图像存在的时候，就不渲染。得到的效果就是，源图片覆盖在目的图像上面。为了更好地理解混合及其参数的含义，请参考这篇文章。</p><p>当然，我们在之前的教程中也有提到过，详情请查看<a href="https://www.cnblogs.com/zilongshanren/archive/2011/07/01/2095479.html" target="_blank" rel="noopener">这篇教程</a>。</p><p>第2行代码是激活混合模式。就这么多！编译并运行，现在，你可以看到一个更加真实的渲染结果啦。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011082619171555.jpg?raw=true" alt=""></p><p>【引用】</p><ul><li><a href="https://www.cnblogs.com/zilongshanren/archive/2011/08/08/2131019.html" target="_blank" rel="noopener">https://www.cnblogs.com/zilongshanren/archive/2011/08/08/2131019.html</a></li><li><a href="http://www.raywenderlich.com/3664/opengl-es-2-0-for-iphone-tutorial" target="_blank" rel="noopener">http://www.raywenderlich.com/3664/opengl-es-2-0-for-iphone-tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在这个系列教程中，我们的目标是帮助大家揭开OpenGL ES 2.0的神秘面纱，同时给大家提供一个手把手的例子，能带领大家步入OpenGL ES 2.0的开发世界。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第一部分教程中，我们介绍了基本的初始化OpenGL，创建简单的顶点和片断shaders，并且在屏幕上面画了一个简单的旋转立方体。&lt;/p&gt;
&lt;p&gt;在这部分教程中，我们将步入更高的级别，给立方体进行纹理贴图！&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="印象笔记" scheme="http://yoursite.com/tags/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES2.0 – iphone开发指引 上</title>
    <link href="http://yoursite.com/2018/10/28/tutorial-for-ios-getting-started-with-opengl-es%2001/"/>
    <id>http://yoursite.com/2018/10/28/tutorial-for-ios-getting-started-with-opengl-es 01/</id>
    <published>2018-10-28T03:09:54.000Z</published>
    <updated>2020-10-28T08:45:55.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OpenGL ES 是可以在iphone上实现2D和3D图形编程的低级API。</p></blockquote><p>如果你之前接触过 cocos2d，sparrow，corona，unity 这些框架，你会发现其实它们都是基于OpenGL上创建的。多数程序员选择使用这些框架，而不是直接调用OpenGL，因为OpenGL实在是太难用了。而这篇教程，就是为了让大家更好地入门而写的。 在这个系列的文章中，你可以通过一些实用又容易上手的实验，创建类似hello world的APP。例如显示一些简单的立体图形。</p><a id="more"></a><p>流程大致如下：</p><ul><li><p>创建一个简单的OpenGL app</p></li><li><p>编译并运行 vertex &amp; fragment shaders</p></li><li><p>通过vertex buffer，在屏幕上渲染一个简单矩形</p></li><li><p>使用投影和 model-view 变形。</p></li><li><p>渲染一个可以 depth testing的3D对象。</p></li></ul><p>说明：我并非OpenGL的专家，这些完全是通过自学得来的。如果大家发现哪些不对的地方，欢迎指出。</p><h2 id="OpenGL-ES1-0-和-OpenGL-ES2-0"><a href="#OpenGL-ES1-0-和-OpenGL-ES2-0" class="headerlink" title="OpenGL ES1.0 和 OpenGL ES2.0"></a>OpenGL ES1.0 和 OpenGL ES2.0</h2><p>第一件你需要搞清楚的事，是OpenGL ES 1.0 和 2.0的区别。<br>他们有多不一样？我只能说他们很不一样。</p><p>OpenGL ES1.0：</p><p>针对固定管线硬件(fixed pipeline)，通过它内建的functions来设置诸如灯光 ，vertexes（图形的顶点数），颜色、camera等等的东西。</p><p>OpenGL ES2.0：</p><p>针对可编程管线硬件(programmable pipeline)，基于这个设计可以让内建函数见鬼去吧，但同时，你得自己动手编写任何功能。</p><p>“TMD”，你可能会这么想。这样子我还可能想用2.0么？</p><p>但2.0确实能做一些很cool而1.0不能做的事情，譬如：toon shader（贴材质）.</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080815453110.jpg?raw=true" alt=""></p><p>利用opengles2.0，甚至还能创建下面的这种很酷的灯光和阴影效果：</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080815461855.jpg?raw=true" alt=""></p><p>OpenGL ES2.0只能够在iphone 3GS+、iPod Touch 3G+ 和所有版本的ipad上运行。庆幸现在大多数用户都在这个范围。　　</p><h2 id="一、开始吧"><a href="#一、开始吧" class="headerlink" title="一、开始吧"></a>一、开始吧</h2><p>尽管Xcode自带了OpenGL ES的项目模板，但这个模板自行创建了大量的代码，这样会让初学者感到迷惘。因此我们通过自行编写的方式来进行，通过一步一步编写，你能更清楚它的工作机制。</p><p>启动Xcode，新建项目-选择Window-based Application, 让我们从零开始。点击下一步，把这个项目命名为HelloOpenGL，点击下一步，选择存放目录，点击“创建”。CMD+R，build and run。你会看到一个空白的屏幕。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080815485029.jpg?raw=true" alt=""></p><p>如你所见的，Window-based 模板创建了一个没有view、没有view controller或者其它东西的项目。它只包含了一个必须的UIWindow。</p><ul><li><p>File/New File,新建文件：选择iOS\Cocoa Touch\Objective-c Class, 点击下一步。</p></li><li><p>选择subclass UIView，点击下一步，命名为 OpenGLView.m., 点击保存。</p></li></ul><p>接下来，你要在这个OpenGLView.m 文件下加入很多代码。</p><h3 id="1）-添加必须的framework-（框架）"><a href="#1）-添加必须的framework-（框架）" class="headerlink" title="1）  添加必须的framework （框架）"></a>1）  添加必须的framework （框架）</h3><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080815495138.jpg?raw=true" alt=""></p><p>加入：OpenGLES.frameworks 和 QuartzCore.framework</p><ul><li><p>在项目的Groups&amp;Files 目录下，选择target “HelloOpenGL”，展开Link Binary with Libraries部分。这里是项目用到的框架。</p></li><li><p>“+”添加，选择OpenGLES.framework, 重复一次把QuartzCore.framework也添加进来。</p></li></ul><h3 id="2）修改OpenGLView-h"><a href="#2）修改OpenGLView-h" class="headerlink" title="2）修改OpenGLView.h"></a>2）修改OpenGLView.h</h3><p>如下：引入OpenGL的Header，创建一些后面会用到的实例变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</span><br><span class="line">#include &lt;OpenGLES/ES2/gl.h&gt;</span><br><span class="line">#include &lt;OpenGLES/ES2/glext.h&gt;</span><br><span class="line"> </span><br><span class="line">@interface OpenGLView : UIView &#123;</span><br><span class="line">    CAEAGLLayer* _eaglLayer;</span><br><span class="line">    EAGLContext* _context;</span><br><span class="line">    GLuint _colorRenderBuffer;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="3）设置layer-class-为-CAEAGLLayer"><a href="#3）设置layer-class-为-CAEAGLLayer" class="headerlink" title="3）设置layer class 为 CAEAGLLayer"></a>3）设置layer class 为 CAEAGLLayer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    return [CAEAGLLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要显示OpenGL的内容，你需要把它缺省的layer设置为一个特殊的layer。（CAEAGLLayer）。这里通过直接复写layerClass的方法。</p><h3 id="4-设置layer为不透明（Opaque）"><a href="#4-设置layer为不透明（Opaque）" class="headerlink" title="4) 设置layer为不透明（Opaque）"></a>4) 设置layer为不透明（Opaque）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupLayer &#123;</span><br><span class="line">    _eaglLayer = (CAEAGLLayer*) self.layer;</span><br><span class="line">    _eaglLayer.opaque = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为缺省的话，CALayer是透明的。而透明的层对性能负荷很大，特别是OpenGL的层。</p><p>（如果可能，尽量都把层设置为不透明。另一个比较明显的例子是自定义tableview cell）</p><h3 id="5）创建OpenGL-context"><a href="#5）创建OpenGL-context" class="headerlink" title="5）创建OpenGL context"></a>5）创建OpenGL context</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupContext &#123;   </span><br><span class="line">    EAGLRenderingAPI api = kEAGLRenderingAPIOpenGLES2;</span><br><span class="line">    _context = [[EAGLContext alloc] initWithAPI:api];</span><br><span class="line">    if (!_context) &#123;</span><br><span class="line">        NSLog(@&quot;Failed to initialize OpenGLES 2.0 context&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (![EAGLContext setCurrentContext:_context]) &#123;</span><br><span class="line">        NSLog(@&quot;Failed to set current OpenGL context&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你要OpenGL帮你实现什么，总需要这个 EAGLContext。EAGLContext管理所有通过OpenGL进行draw的信息。这个与Core Graphics context类似。当你创建一个context，你要声明你要用哪个version的API。这里，我们选择OpenGL ES 2.0.</p><p>（容错处理，如果创建失败了，我们的程序会退出）</p><h3 id="6）创建render-buffer-（渲染缓冲区）"><a href="#6）创建render-buffer-（渲染缓冲区）" class="headerlink" title="6）创建render buffer （渲染缓冲区）"></a>6）创建render buffer （渲染缓冲区）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupRenderBuffer &#123;</span><br><span class="line">    glGenRenderbuffers(1, &amp;_colorRenderBuffer);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);        </span><br><span class="line">    [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Render buffer 是OpenGL的一个对象，用于存放渲染过的图像。有时候你会发现render buffer会作为一个color buffer被引用，因为本质上它就是存放用于显示的颜色。</p><p>创建render buffer的三步：</p><ol><li>调用glGenRenderbuffers来创建一个新的render buffer object。这里返回一个唯一的integer来标记render buffer（这里把这个唯一值赋值到_colorRenderBuffer）。有时候你会发现这个唯一值被用来作为程序内的一个OpenGL 的名称。（反正它唯一嘛）</li><li>调用glBindRenderbuffer ，告诉这个OpenGL：我在后面引用GL_RENDERBUFFER的地方，其实是想用_colorRenderBuffer。其实就是告诉OpenGL，我们定义的buffer对象是属于哪一种OpenGL对象</li><li>最后，为render buffer分配空间。renderbufferStorage</li></ol><h3 id="7）创建一个-frame-buffer-（帧缓冲区）"><a href="#7）创建一个-frame-buffer-（帧缓冲区）" class="headerlink" title="7）创建一个 frame buffer （帧缓冲区）"></a>7）创建一个 frame buffer （帧缓冲区）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupFrameBuffer &#123;    </span><br><span class="line">    GLuint framebuffer;</span><br><span class="line">    glGenFramebuffers(1, &amp;framebuffer);</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, </span><br><span class="line">        GL_RENDERBUFFER, _colorRenderBuffer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Frame buffer也是OpenGL的对象，它包含了前面提到的render buffer，以及其它后面会讲到的诸如：depth buffer、stencil buffer 和 accumulation buffer。前两步创建frame buffer的动作跟创建render buffer的动作很类似。（反正也是用一个glBind什么的）而最后一步  glFramebufferRenderbuffer 这个才有点新意。它让你把前面创建的buffer render依附在frame buffer的GL_COLOR_ATTACHMENT0位置上。</p><h3 id="8）清理屏幕"><a href="#8）清理屏幕" class="headerlink" title="8）清理屏幕"></a>8）清理屏幕</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)render &#123;</span><br><span class="line">    glClearColor(0, 104.0/255.0, 55.0/255.0, 1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了尽快在屏幕上显示一些什么，在我们和那些 vertexes、shaders打交道之前，把屏幕清理一下，显示另一个颜色吧。（RGB 0, 104, 55，绿色吧）</p><p>这里每个RGB色的范围是0~1，所以每个要除一下255.</p><p>下面解析一下每一步动作：</p><ol><li>调用glClearColor ，设置一个RGB颜色和透明度，接下来会用这个颜色涂满全屏。</li><li>调用glClear来进行这个“填色”的动作（大概就是photoshop那个油桶嘛）。还记得前面说过有很多buffer的话，这里我们要用到GL_COLOR_BUFFER_BIT来声明要清理哪一个缓冲区。</li><li>调用OpenGL context的presentRenderbuffer方法，把缓冲区（render buffer和color buffer）的颜色呈现到UIView上。</li></ol><h3 id="9）把前面的动作串起来修改一下OpenGLView-m"><a href="#9）把前面的动作串起来修改一下OpenGLView-m" class="headerlink" title="9）把前面的动作串起来修改一下OpenGLView.m"></a>9）把前面的动作串起来修改一下OpenGLView.m</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Replace initWithFrame with this</span><br><span class="line">- (id)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;        </span><br><span class="line">        [self setupLayer];        </span><br><span class="line">        [self setupContext];                </span><br><span class="line">        [self setupRenderBuffer];        </span><br><span class="line">        [self setupFrameBuffer];                </span><br><span class="line">        [self render];        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Replace dealloc method with this</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [_context release];</span><br><span class="line">    _context = nil;</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10）把App-Delegate和OpenGLView-连接起来"><a href="#10）把App-Delegate和OpenGLView-连接起来" class="headerlink" title="10）把App Delegate和OpenGLView 连接起来"></a>10）把App Delegate和OpenGLView 连接起来</h3><p>在HelloOpenGLAppDelegate.h 中修改一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// At top of file</span><br><span class="line">#import &quot;OpenGLView.h&quot;</span><br><span class="line"> </span><br><span class="line">// Inside @interface</span><br><span class="line">OpenGLView* _glView;</span><br><span class="line"> </span><br><span class="line">// After @interface</span><br><span class="line">@property (nonatomic, retain) IBOutlet OpenGLView *glView;</span><br></pre></td></tr></table></figure><p>接下来修改.m文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// At top of file</span><br><span class="line">@synthesize glView=_glView;</span><br><span class="line"> </span><br><span class="line">// At top of application:didFinishLaunchingWithOptions</span><br><span class="line">CGRect screenBounds = [[UIScreen mainScreen] bounds];    </span><br><span class="line">self.glView = [[[OpenGLView alloc] initWithFrame:screenBounds] autorelease];</span><br><span class="line">[self.window addSubview:_glView];</span><br><span class="line"> </span><br><span class="line">// In dealloc</span><br><span class="line">[_glView release];</span><br></pre></td></tr></table></figure><p>一切顺利的话，你就能看到一个新的view在屏幕上显示，这里是OpenGL的世界。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080815590542.jpg?raw=true" alt=""></p><h2 id="二、添加shaders：顶点着色器和片段着色器"><a href="#二、添加shaders：顶点着色器和片段着色器" class="headerlink" title="二、添加shaders：顶点着色器和片段着色器"></a>二、添加shaders：顶点着色器和片段着色器</h2><p>在OpenGL ES2.0 的世界，在场景中渲染任何一种几何图形，你都需要创建两个称之为“着色器”的小程序。</p><p>着色器由一个类似C的语言编写- GLSL。知道就好了，我们不深究。</p><p>这个世界有两种着色器（Shader）：</p><ul><li><p>Vertex shaders – 在你的场景中，每个顶点都需要调用的程序，称为“顶点着色器”。假如你在渲染一个简单的场景：一个长方形，每个角只有一个顶点。于是vertex shader 会被调用四次。它负责执行：诸如灯光、几何变换等等的计算。得出最终的顶点位置后，为下面的片段着色器提供必须的数据。</p></li><li><p>Fragment shaders – 在你的场景中，大概每个像素都会调用的程序，称为“片段着色器”。在一个简单的场景，也是刚刚说到的长方形。这个长方形所覆盖到的每一个像素，都会调用一次fragment shader。片段着色器的责任是计算灯光，以及更重要的是计算出每个像素的最终颜色。</p></li></ul><p>下面我们通过简单的例子来说明。</p><p>打开你的xcode，File\New\New File… 选择iOS\Other\Empty, 点击下一步。命名为：SimpleVertex.glsl 点击保存。打开这个文件，加入下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">attribute vec4 Position; // 1</span><br><span class="line">attribute vec4 SourceColor; // 2</span><br><span class="line"> </span><br><span class="line">varying vec4 DestinationColor; // 3</span><br><span class="line"> </span><br><span class="line">void main(void) &#123; // 4</span><br><span class="line">   DestinationColor = SourceColor; // 5</span><br><span class="line">   gl_Position = Position; // 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一行一行解析：</p><ol><li><p>“attribute”声明了这个shader会接受一个传入变量，这个变量名为“Position”。在后面的代码中，你会用它来传入顶点的位置数据。这个变量的类型是“vec4”,表示这是一个由4部分组成的矢量。</p></li><li><p>与上面同理，这里是传入顶点的颜色变量。</p></li><li><p>这个变量没有“attribute”的关键字。表明它是一个传出变量，它就是会传入片段着色器的参数。“varying”关键字表示，依据顶点的颜色，平滑计算出顶点之间每个像素的颜色。</p><p>文字比较难懂，我们一图胜千言：<br>图中的一个像素，它位于红色和绿色的顶点之间，准确地说，这是一个距离上面顶点55/100，距离下面顶点45/100的点。所以通过过渡，能确定这个像素的颜色。<br><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816012443.jpg?raw=true" alt=""></p></li><li><p>每个shader都从main开始– 跟C一样嘛。</p></li><li><p>设置目标颜色 = 传入变量：SourceColor</p></li><li><p>gl_Position 是一个内建的传出变量。这是一个在 vertex shader中必须设置的变量。这里我们直接把gl_Position = Position; 没有做任何逻辑运算。</p></li></ol><p>一个简单的vertex shader 就是这样了，接下来我们再创建一个简单的fragment shader。</p><p>深入了解着色器：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/" target="_blank" rel="noopener">着色器详解</a></p><p>新建一个空白文件：</p><ul><li><p>File\New\New File… 选择iOS\Other\Empty</p></li><li><p>命名为：SimpleFragment.glsl 保存。</p></li></ul><p>打开这个文件，加入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">varying lowp vec4 DestinationColor; // 1</span><br><span class="line"> </span><br><span class="line">void main(void) &#123; // 2</span><br><span class="line">    gl_FragColor = DestinationColor; // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解析：</p><ol><li>这是从vertex shader中传入的变量，这里和vertex shader定义的一致。而额外加了一个关键字：lowp。在fragment shader中，必须给出一个计算的精度。出于性能考虑，总使用最低精度是一个好习惯。这里就是设置成最低的精度。如果你需要，也可以设置成medp或者highp.</li><li>也是从main开始嘛</li><li>正如你在vertex shader中必须设置gl_Position, 在fragment shader中必须设置gl_FragColor.</li></ol><p>这里也是直接从 vertex shader中取值，先不做任何改变，还可以吧？接下来我们开始运用这些shader来创建我们的app。</p><h3 id="1）编译-Vertex-shader-和-Fragment-shader"><a href="#1）编译-Vertex-shader-和-Fragment-shader" class="headerlink" title="1）编译 Vertex shader 和 Fragment shader"></a>1）编译 Vertex shader 和 Fragment shader</h3><p>目前为止，xcode仅仅会把这两个文件copy到application bundle中。我们还需要在运行时编译和运行这些shader。你可能会感到诧异。为什么要在app运行时编译代码？这样做的好处是，我们的着色器不用依赖于某种图形芯片。（这样才可以跨平台嘛）</p><p>下面开始加入动态编译的代码，打开OpenGLView.m，在initWithFrame: 方法上方加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (GLuint)compileShader:(NSString*)shaderName withType:(GLenum)shaderType &#123;</span><br><span class="line"> </span><br><span class="line">    // 1</span><br><span class="line">    NSString* shaderPath = [[NSBundle mainBundle] pathForResource:shaderName </span><br><span class="line">        ofType:@&quot;glsl&quot;];</span><br><span class="line">    NSError* error;</span><br><span class="line">    NSString* shaderString = [NSString stringWithContentsOfFile:shaderPath </span><br><span class="line">        encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">    if (!shaderString) &#123;</span><br><span class="line">        NSLog(@&quot;Error loading shader: %@&quot;, error.localizedDescription);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 2</span><br><span class="line">    GLuint shaderHandle = glCreateShader(shaderType);    </span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    const char* shaderStringUTF8 = [shaderString UTF8String];    </span><br><span class="line">    int shaderStringLength = (int)[shaderString length];</span><br><span class="line">    glShaderSource(shaderHandle, 1, &amp;shaderStringUTF8, &amp;shaderStringLength);</span><br><span class="line"> </span><br><span class="line">    // 4</span><br><span class="line">    glCompileShader(shaderHandle);</span><br><span class="line"> </span><br><span class="line">    // 5</span><br><span class="line">    GLint compileSuccess;</span><br><span class="line">    glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &amp;compileSuccess);</span><br><span class="line">    if (compileSuccess == GL_FALSE) &#123;</span><br><span class="line">        GLchar messages[256];</span><br><span class="line">        glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &amp;messages[0]);</span><br><span class="line">        NSString *messageString = [NSString stringWithUTF8String:messages];</span><br><span class="line">        NSLog(@&quot;%@&quot;, messageString);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return shaderHandle;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解析：</p><ol><li>这是一个UIKit编程的标准用法，就是在NSBundle中查找某个文件。大家应该熟悉了吧。</li><li>调用 glCreateShader来创建一个代表shader 的OpenGL对象。这时你必须告诉OpenGL，你想创建 fragment shader还是vertex shader。所以便有了这个参数：shaderType</li><li>调用glShaderSource ，让OpenGL获取到这个shader的源代码。（就是我们写的那个）这里我们还把NSString转换成C-string</li><li>最后，调用glCompileShader 在运行时编译shader</li><li>大家都是程序员，有程序的地方就会有fail。有程序员的地方必然会有debug。如果编译失败了，我们必须一些信息来找出问题原因。 glGetShaderiv 和 glGetShaderInfoLog  会把error信息输出到屏幕。（然后退出）</li></ol><p>我们还需要一些步骤来编译vertex shader 和frament shader。</p><ul><li>把它们俩关联起来</li><li>告诉OpenGL来调用这个程序，还需要一些指针什么的。</li></ul><p>在compileShader: 方法下方，加入这些代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)compileShaders &#123;</span><br><span class="line"> </span><br><span class="line">    // 1</span><br><span class="line">    GLuint vertexShader = [self compileShader:@&quot;SimpleVertex&quot; </span><br><span class="line">        withType:GL_VERTEX_SHADER];</span><br><span class="line">    GLuint fragmentShader = [self compileShader:@&quot;SimpleFragment&quot; </span><br><span class="line">        withType:GL_FRAGMENT_SHADER];</span><br><span class="line"> </span><br><span class="line">    // 2</span><br><span class="line">    GLuint programHandle = glCreateProgram();</span><br><span class="line">    glAttachShader(programHandle, vertexShader);</span><br><span class="line">    glAttachShader(programHandle, fragmentShader);</span><br><span class="line">    glLinkProgram(programHandle);</span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    GLint linkSuccess;</span><br><span class="line">    glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);</span><br><span class="line">    if (linkSuccess == GL_FALSE) &#123;</span><br><span class="line">        GLchar messages[256];</span><br><span class="line">        glGetProgramInfoLog(programHandle, sizeof(messages), 0, &amp;messages[0]);</span><br><span class="line">        NSString *messageString = [NSString stringWithUTF8String:messages];</span><br><span class="line">        NSLog(@&quot;%@&quot;, messageString);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 4</span><br><span class="line">    glUseProgram(programHandle);</span><br><span class="line"> </span><br><span class="line">    // 5</span><br><span class="line">    _positionSlot = glGetAttribLocation(programHandle, &quot;Position&quot;);</span><br><span class="line">    _colorSlot = glGetAttribLocation(programHandle, &quot;SourceColor&quot;);</span><br><span class="line">    glEnableVertexAttribArray(_positionSlot);</span><br><span class="line">    glEnableVertexAttribArray(_colorSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是解析：</p><ol><li>用来调用你刚刚写的动态编译方法，分别编译了vertex shader 和 fragment shader</li><li>调用了glCreateProgram glAttachShader  glLinkProgram 连接 vertex 和 fragment shader成一个完整的program。</li><li>调用 glGetProgramiv  lglGetProgramInfoLog 来检查是否有error，并输出信息。</li><li>调用 glUseProgram  让OpenGL真正执行你的program</li><li>最后，调用 glGetAttribLocation 来获取指向 vertex shader传入变量的指针。以后就可以通过这写指针来使用了。还有调用 glEnableVertexAttribArray来启用这些数据。（因为默认是 disabled的。）</li></ol><p>最后还有两步：</p><ul><li>在@interface in OpenGLView.h 中添加两个变量：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint _positionSlot;</span><br><span class="line">GLuint _colorSlot;</span><br></pre></td></tr></table></figure><ul><li>在 initWithFrame方法里，在调用render之前要加入这个：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self compileShaders];</span><br></pre></td></tr></table></figure><p>编译！运行！</p><p>如果你仍能正常地看到之前那个绿色的屏幕，就证明你前面写的代码都很好地工作了。</p><h2 id="三、为这个简单的长方形创建-Vertex-Data！"><a href="#三、为这个简单的长方形创建-Vertex-Data！" class="headerlink" title="三、为这个简单的长方形创建 Vertex Data！"></a>三、为这个简单的长方形创建 Vertex Data！</h2><p>在这里，我们打算在屏幕上渲染一个正方形，如下图：</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816061947.jpg?raw=true" alt=""></p><p>在你用OpenGL渲染图形的时候，时刻要记住一点，你只能直接渲染三角形，而不是其它诸如矩形的图形。所以，一个正方形需要分开成两个三角形来渲染。</p><p>图中分别是顶点（0,1,2）和顶点（0,2,3）构成的三角形。</p><p>OpenGL ES2.0的一个好处是，你可以按你的风格来管理顶点。</p><h3 id="1）矩形信息"><a href="#1）矩形信息" class="headerlink" title="1）矩形信息"></a>1）矩形信息</h3><p>打开OpenGLView.m文件，创建一个纯粹的C结构以及一些array来跟踪我们的矩形信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    float Position[3];</span><br><span class="line">    float Color[4];</span><br><span class="line">&#125; Vertex;</span><br><span class="line"> </span><br><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 0, 1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 0, 0, 1&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const GLubyte Indices[] = &#123;</span><br><span class="line">     0, 1, 2,</span><br><span class="line">     2, 3, 0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码的作用是：</p><ol><li>一个用于跟踪所有顶点信息的结构Vertex （目前只包含位置和颜色。）</li><li>定义了以上面这个Vertex结构为类型的array。</li><li>一个用于表示三角形顶点的数组。</li></ol><p>数据准备好了，我们来开始把数据传入OpenGL</p><h3 id="2）创建Vertex-Buffer-对象"><a href="#2）创建Vertex-Buffer-对象" class="headerlink" title="2）创建Vertex Buffer 对象"></a>2）创建Vertex Buffer 对象</h3><p>传数据到OpenGL的话，最好的方式就是用Vertex Buffer对象。</p><p>基本上，它们就是用于缓存顶点数据的OpenGL对象。通过调用一些function来把数据发送到OpenGL-land。（是指OpenGL的画面？）</p><p>这里有两种顶点缓存类型– 一种是用于跟踪每个顶点信息的（正如我们的Vertices array），另一种是用于跟踪组成每个三角形的索引信息（我们的Indices array）。</p><p>下面我们在initWithFrame中，加入一些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self setupVBOs];</span><br></pre></td></tr></table></figure><p>下面是定义这个setupVBOs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupVBOs &#123;</span><br><span class="line"> </span><br><span class="line">    GLuint vertexBuffer;</span><br><span class="line">    glGenBuffers(1, &amp;vertexBuffer);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">    GLuint indexBuffer;</span><br><span class="line">    glGenBuffers(1, &amp;indexBuffer);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，其实很简单的。这其实是一种之前也用过的模式（pattern）。</p><ul><li><p>glGenBuffs - 创建一个Vertex Buffer 对象</p></li><li><p>glBindBur – 告诉OpenGL我们的vertexBuffer 是指GL_ARRAY_BUFFER</p></li><li><p>glBufferData – 把数据传到OpenGL-land</p></li></ul><p>想起哪里用过这个模式吗？要不再回去看看frame buffer那一段？ </p><p>万事俱备，我们可以通过新的shader，用新的渲染方法来把顶点数据画到屏幕上。</p><p>用这段代码替换掉之前的render：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)render &#123;</span><br><span class="line">    glClearColor(0, 104.0/255.0, 55.0/255.0, 1.0);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"> </span><br><span class="line">    // 1</span><br><span class="line">    glViewport(0, 0, self.frame.size.width, self.frame.size.height);</span><br><span class="line"> </span><br><span class="line">    // 2</span><br><span class="line">    glVertexAttribPointer(_positionSlot, 3, GL_FLOAT, GL_FALSE, </span><br><span class="line">        sizeof(Vertex), 0);</span><br><span class="line">    glVertexAttribPointer(_colorSlot, 4, GL_FLOAT, GL_FALSE, </span><br><span class="line">        sizeof(Vertex), (GLvoid*) (sizeof(float) *3));</span><br><span class="line"> </span><br><span class="line">    // 3</span><br><span class="line">    glDrawElements(GL_TRIANGLES, sizeof(Indices)/sizeof(Indices[0]), </span><br><span class="line">        GL_UNSIGNED_BYTE, 0);</span><br><span class="line"> </span><br><span class="line">    [_context presentRenderbuffer:GL_RENDERBUFFER];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、调用glViewport 设置UIView中用于渲染的部分。这个例子中指定了整个屏幕。但如果你希望用更小的部分，你可以更变这些参数。</p><p>2、调用glVertexAttribPointer来为vertex shader的两个输入参数配置两个合适的值。</p><p>第二段这里，是一个很重要的方法，让我们来认真地看看它是如何工作的：</p><ul><li><p>第一个参数，声明这个属性的名称，之前我们称之为glGetAttribLocation</p></li><li><p>第二个参数，定义这个属性由多少个值组成。譬如说position是由3个float（x,y,z）组成，而颜色是4个float（r,g,b,a）</p></li><li>第三个，声明每一个值是什么类型。（这例子中无论是位置还是颜色，我们都用了GL_FLOAT）</li><li>第四个，嗯……它总是false就好了。</li><li>第五个，指 stride 的大小。这是一个种描述每个 vertex数据大小的方式。所以我们可以简单地传入 sizeof（Vertex），让编译器计算出来就好。</li><li>最后一个，是这个数据结构的偏移量。表示在这个结构中，从哪里开始获取我们的值。Position的值在前面，所以传0进去就可以了。而颜色是紧接着位置的数据，而position的大小是3个float的大小，所以是从 3 * sizeof(float) 开始的。</li></ul><p>回来继续说代码，第三点：</p><p>3、调用glDrawElements ，它最后会在每个vertex上调用我们的vertex shader，以及每个像素调用fragment shader，最终画出我们的矩形。</p><p>它也是一个重要的方法，我们来仔细研究一下：</p><ul><li>第一个参数，声明用哪种特性来渲染图形。有GL_LINE_STRIP 和 GL_TRIANGLE_FAN。然而GL_TRIANGLE是最常用的，特别是与VBO 关联的时候。</li><li>第二个，告诉渲染器有多少个图形要渲染。我们用到C的代码来计算出有多少个。这里是通过个 array的byte大小除以一个Indice类型的大小得到的。</li><li>第三个，指每个indices中的index类型</li><li>最后一个，在官方文档中说，它是一个指向index的指针。但在这里，我们用的是VBO，所以通过index的array就可以访问到了（在GL_ELEMENT_ARRAY_BUFFER传过了），所以这里不需要.</li></ul><p>编译运行的话，你就可以看到这个画面</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816112431.jpg?raw=true" alt=""></p><p>你可能会疑惑，为什么这个长方形刚好占满整个屏幕。在缺省状态下，OpenGL的“camera”位于（0,0,0）位置，朝z轴的正方向。</p><p>当然，后面我们会讲到projection（投影）以及如何控制camera。</p><h3 id="3）增加一个投影"><a href="#3）增加一个投影" class="headerlink" title="3）增加一个投影"></a>3）增加一个投影</h3><p>为了在2D屏幕上显示3D画面，我们需要在图形上做一些投影变换，所谓投影就是下图这个意思：</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816120726.jpg?raw=true" alt=""></p><p>基本上，为了模仿人类的眼球原理。我们设置一个远平面和一个近平面，在两个平面之前，离近平面近的图像，会因为被缩小了而显得变小；而离远平面近的图像，也会因此而变大。</p><p>打开SimpleVertex.glsl，做一下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Add right before the main</span><br><span class="line">uniform mat4 Projection;</span><br><span class="line"> </span><br><span class="line">// Modify gl_Position line as follows</span><br><span class="line">gl_Position = Projection * Position;</span><br></pre></td></tr></table></figure><p>这里我们增加了一个叫做projection的传入变量。uniform 关键字表示，这会是一个应用于所有顶点的常量，而不是会因为顶点不同而不同的值。</p><p>mat4 是 4X4矩阵的意思。然而，Matrix math是一个很大的课题，我们不可能在这里解析。所以在这里，你只要认为它是用于放大缩小、旋转、变形就好了。</p><p>Position位置乘以Projection矩阵，我们就得到最终的位置数值。</p><p>无错，这就是一种被称之“线性代数”的东西。我在大学时期后，早就忘大部分了。</p><p>其实数学也只是一种工具，而这种工具已经由前面的才子解决了，我们知道怎么用就好。</p><p>Bill Hollings，cocos3d的作者。他编写了一个完整的3D特性框架，并整合到cocos2d中。（作者：可能有一天我也会弄一个3D的教程）无论任何，Cocos3d包含了Objective-C的向量和矩阵库，所以我们可以很好地应用到这个项目中。</p><p>这里，<a href="https://github.com/sqjuanke/learnopengl/tree/master/resource/code/Cocos3DMathLib" target="_blank" rel="noopener">https://github.com/sqjuanke/learnopengl/tree/master/resource/code/Cocos3DMathLib</a></p><p>（作者：我移除了一些不必要的依赖）下载并copy到你的项目中。记得选上：“Copy items into destination group’s folder (if needed)” 点击Finish。</p><p>在OpenGLView.h 中加入一个实例变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint _projectionUniform;</span><br></pre></td></tr></table></figure><p>然后到OpenGLView.m文件中加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Add to top of file</span><br><span class="line">#import &quot;CC3GLMatrix.h&quot;</span><br><span class="line"> </span><br><span class="line">// Add to bottom of compileShaders</span><br><span class="line">_projectionUniform = glGetUniformLocation(programHandle, &quot;Projection&quot;);</span><br><span class="line"> </span><br><span class="line">// Add to render, right before the call to glViewport</span><br><span class="line">CC3GLMatrix *projection = [CC3GLMatrix matrix];</span><br><span class="line">float h =4.0f* self.frame.size.height / self.frame.size.width;</span><br><span class="line">[projection populateFromFrustumLeft:-2 andRight:2 andBottom:-h/2 andTop:h/2 andNear:4 andFar:10];</span><br><span class="line">glUniformMatrix4fv(_projectionUniform, 1, 0, projection.glMatrix);</span><br><span class="line"> </span><br><span class="line">// Modify vertices so they are within projection near/far planes</span><br><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, -7&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, -7&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -7&#125;, &#123;0, 0, 1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, -7&#125;, &#123;0, 0, 0, 1&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过调用  glGetUniformLocation 来获取在vertex shader中的Projection输入变量</p><p>然后，使用math library来创建投影矩阵。通过这个让你指定坐标，以及远近屏位置的方式，来创建矩阵，会让事情比较简单。</p><p>你用来把数据传入到vertex shader的方式，叫做 glUniformMatrix4fv. 这个CC3GLMatrix类有一个很方便的方法 glMatrix,来把矩阵转换成OpenGL的array格式。</p><p>最后，把之前的vertices数据修改一下，让z坐标为－７． </p><p>编译后运行，你应该可以看到一个稍稍有点距离的正方形了。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816172995.jpg?raw=true" alt=""></p><h2 id="尝试移动和旋转吧"><a href="#尝试移动和旋转吧" class="headerlink" title="尝试移动和旋转吧"></a>尝试移动和旋转吧</h2><p>如果总是要修改那个vertex array才能改变图形，这就太烦人了。而这正是变换矩阵该做的事（又来了，线性代数）</p><p>在前面，我们修改了应用到投影矩阵的vertex array来达到移动图形的目的。何不试一下，做一个变形、放大缩小、旋转的矩阵来应用？我们称之为“model-view”变换。</p><p>再回到 SimpleVertex.glsl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Add right after the Projection uniform</span><br><span class="line">uniform mat4 Modelview;</span><br><span class="line"> </span><br><span class="line">// Modify the gl_Position line</span><br><span class="line">gl_Position = Projection * Modelview * Position;</span><br></pre></td></tr></table></figure><p>就是又加了一个 Uniform的矩阵而已。顺便把它应用到gl_Position当中。</p><p>然后到 OpenGLView.h中加上一个变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint _modelViewUniform;</span><br></pre></td></tr></table></figure><p>到OpenGLView.m中修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Add to end of compileShaders</span><br><span class="line">_modelViewUniform = glGetUniformLocation(programHandle, &quot;Modelview&quot;);</span><br><span class="line"> </span><br><span class="line">// Add to render, right before call to glViewport</span><br><span class="line">CC3GLMatrix *modelView = [CC3GLMatrix matrix];</span><br><span class="line">[modelView populateFromTranslation:CC3VectorMake(sin(CACurrentMediaTime()), 0, -7)];</span><br><span class="line">glUniformMatrix4fv(_modelViewUniform, 1, 0, modelView.glMatrix);</span><br><span class="line"> </span><br><span class="line">// Revert vertices back to z-value 0</span><br><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 0, 1, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 0, 0, 1&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>获取那个model view uniform的传入变量</p><p>使用cocos3d math库来创建一个新的矩阵，在变换中装入矩阵。</p><p>变换是在z轴上移动-7，而为什么sin(当前时间) 呢？</p><p>哈哈，如果你还记得高中时候的三角函数。sin()是一个从-1到1的函数。已PI（3.14）为一个周期。这样做的话，约每3.14秒，这个函数会从-1到1循环一次。</p><p>把vertex 结构改回去，把z坐标设回0.</p><p>编译运行，就算我们把z设回0，也可以看到这个位于中间的正方形了。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816192747.jpg?raw=true" alt=""></p><p>什么？一动不动的？</p><p>当然了，我们只是调用了一次render方法。</p><p>接下来，我们在每一帧都调用一次看看。</p><h3 id="渲染和-CADisplayLink"><a href="#渲染和-CADisplayLink" class="headerlink" title="渲染和 CADisplayLink"></a>渲染和 CADisplayLink</h3><p>理想状态下，我们希望OpenGL的渲染频率跟屏幕的刷新频率一致。</p><p>幸运的是，Apple为我们提供了一个CADisplayLink的类。这个很好用的，马上就用吧。</p><p>在OpenGLView.m文件，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Add new method before init</span><br><span class="line">- (void)setupDisplayLink &#123;</span><br><span class="line">    CADisplayLink* displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(render:)];</span><br><span class="line">    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Modify render method to take a parameter</span><br><span class="line">- (void)render:(CADisplayLink*)displayLink &#123;</span><br><span class="line"> </span><br><span class="line">// Remove call to render in initWithFrame and replace it with the following</span><br><span class="line">[self setupDisplayLink];</span><br></pre></td></tr></table></figure><p>这就行了，有CADisplayLink在每一帧都调用你的render方法，我们的图形看起身就好似被sin()周期地变型了。现在这个方块会前前后后地来回移动。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816205251.jpg?raw=true" alt=""></p><h3 id="不费功夫地旋转"><a href="#不费功夫地旋转" class="headerlink" title="不费功夫地旋转"></a>不费功夫地旋转</h3><p>让图形旋转起来，才算得上有型。</p><p>再到OpenGLView.h 中，添加成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float _currentRotation;</span><br></pre></td></tr></table></figure><p>在OpenGLView.m的render中，在populateFromTranslation的调用后面加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_currentRotation += displayLink.duration *90;</span><br><span class="line">[modelView rotateBy:CC3VectorMake(_currentRotation, _currentRotation, 0)];</span><br></pre></td></tr></table></figure><p>添加了一个叫_currentRotation的float，每秒会增加90度。</p><p>通过修改那个model view矩阵（这里相当于一个用于变型的矩阵），增加旋转。</p><p>旋转在x、y轴上作用，没有在z轴的。</p><p>编译运行，你会看到一个很有型的翻转的3D效果。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816220098.jpg?raw=true" alt=""></p><h3 id="不费功夫地变成3D方块？"><a href="#不费功夫地变成3D方块？" class="headerlink" title="不费功夫地变成3D方块？"></a>不费功夫地变成3D方块？</h3><p>之前的只能算是2.5D,因为它还只是一个会旋转的面而已。现在我们把它改造成3D的。</p><p>把之前的vertices、indices数组注释掉吧。</p><p>然后加上新的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const Vertex Vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, 0&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, 0&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, 0&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, 0&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, -1, -1&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;1, 1, -1&#125;, &#123;1, 0, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, 1, -1&#125;, &#123;0, 1, 0, 1&#125;&#125;,</span><br><span class="line">    &#123;&#123;-1, -1, -1&#125;, &#123;0, 1, 0, 1&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const GLubyte Indices[] = &#123;</span><br><span class="line">    // Front</span><br><span class="line">0, 1, 2,</span><br><span class="line">    2, 3, 0,</span><br><span class="line">    // Back</span><br><span class="line">4, 6, 5,</span><br><span class="line">    4, 7, 6,</span><br><span class="line">    // Left</span><br><span class="line">2, 7, 3,</span><br><span class="line">    7, 6, 2,</span><br><span class="line">    // Right</span><br><span class="line">0, 4, 1,</span><br><span class="line">    4, 1, 5,</span><br><span class="line">    // Top</span><br><span class="line">6, 2, 1, </span><br><span class="line">    1, 6, 5,</span><br><span class="line">    // Bottom</span><br><span class="line">0, 3, 7,</span><br><span class="line">    0, 7, 4    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译运行，你会看到一个方块了。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816282932.jpg?raw=true" alt=""></p><p>但这个方块有时候让人觉得假，因为你可以看到方块里面。</p><p>这里还有一个叫做 depth testing（深度测试）的功能，启动它，OpenGL就可以跟踪在z轴上的像素。这样它只会在那个像素前方没有东西时，才会绘画这个像素。</p><p>到OpenGLView.h中，添加成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint _depthRenderBuffer;</span><br></pre></td></tr></table></figure><p>在OpenGLView.m:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Add new method right after setupRenderBuffer</span><br><span class="line">- (void)setupDepthBuffer &#123;</span><br><span class="line">    glGenRenderbuffers(1, &amp;_depthRenderBuffer);</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBuffer);</span><br><span class="line">    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, self.frame.size.width, self.frame.size.height);    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Add to end of setupFrameBuffer</span><br><span class="line">glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBuffer);</span><br><span class="line"> </span><br><span class="line">// In the render method, replace the call to glClear with the following</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line"> </span><br><span class="line">// Add to initWithFrame, right before call to setupRenderBuffer</span><br><span class="line">[self setupDepthBuffer];</span><br></pre></td></tr></table></figure><p>setupDepthBuffer方法创建了一个depth buffer。这个与前面的render/color buffer类似，不再重复了。值得注意的是，这里使用了glRenderbufferStorage, 然不是context的renderBufferStorage（这个是在OpenGL的view中特别为color render buffer而设的）。</p><p>接着，我们调用glFramebufferRenderbuffer，来关联depth buffer和render buffer。还记得，我说过frame buffer中储存着很多种不同的buffer？这正是一个新的buffer。</p><p>在render方法中，我们在每次update时都清除深度buffer，并启用depth  testing。</p><p>编译运行，看看这个教程最后的效果。</p><p>一个选择的立方块，用到了OpenGL ES2.0。</p><p><img src="https://github.com/sqjuanke/learnopengl/blob/master/resource/images/2011080816303365.jpg?raw=true" alt=""></p><p>【引用】</p><ul><li><a href="https://www.cnblogs.com/zilongshanren/archive/2011/08/08/2131019.html" target="_blank" rel="noopener">https://www.cnblogs.com/zilongshanren/archive/2011/08/08/2131019.html</a></li><li><a href="http://www.raywenderlich.com/3664/opengl-es-2-0-for-iphone-tutorial" target="_blank" rel="noopener">http://www.raywenderlich.com/3664/opengl-es-2-0-for-iphone-tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;OpenGL ES 是可以在iphone上实现2D和3D图形编程的低级API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你之前接触过 cocos2d，sparrow，corona，unity 这些框架，你会发现其实它们都是基于OpenGL上创建的。多数程序员选择使用这些框架，而不是直接调用OpenGL，因为OpenGL实在是太难用了。而这篇教程，就是为了让大家更好地入门而写的。 在这个系列的文章中，你可以通过一些实用又容易上手的实验，创建类似hello world的APP。例如显示一些简单的立体图形。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="印象笔记" scheme="http://yoursite.com/tags/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 初识</title>
    <link href="http://yoursite.com/2018/03/28/flutter/"/>
    <id>http://yoursite.com/2018/03/28/flutter/</id>
    <published>2018-03-28T08:05:21.000Z</published>
    <updated>2020-10-27T05:55:23.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>西班牙巴塞罗那世界移动大会上，Google发布了第一个beta版的Flutter，前前后后也看了一些视频以及讲解。感觉还是比较靠谱的跨平台，最近自己倒腾了一下，才发现开发原来可以这样来。</p></blockquote><p>Flutter是一个软件开发工具包，可以不过多依赖原系统从而构建高性能，以及高保真的iOS，Android应用程序，在排版布局交互上能够较高的保证用户体验。</p><a id="more"></a><p>我们先来看看几个亮点</p><ul><li>跨平台</li></ul><p>这个是最主要的亮点，也是Flutter得以发展的根基，无论是开发者，还是老板都希望一个人可以解决前端的所有工作，而不是iOS，Android，前端。当然现在很多再强调大前端，但其实只能说是一个人得需要具备多门技术。而Flutter则只需要一套代码就可以同时运行在两个端，当然有人会提到RN，也是可以完成跨平台，但其构建机制其实是基于原系统的UI进行“封装”，并不能算是完整意义上的跨平台。</p><p>相对于nativeApp, webviewApp, React native的区别我们可以看几个对比图</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/LlVYHz1x5wqQC5i4uEKcgCKCSMYO5Hs9nxCw7VLpu6k!/r/dJEAAAAAAAAA" alt="logo" title="NativeApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/2*IYhakRVUVMOJp8fN*nImpLNKaUzRO.JFCN.hR8Jz4!/r/dEIBAAAAAAAA" alt="logo" title="FlutterApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/sR50fd*l.QWTumAEa8Cp92oM6UuD6kiZx95VdcKLQPc!/r/dGoBAAAAAAAA" alt="logo" title="WebviewApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/Ld0Z8i91poM.STZ26MvWnyCNUv.JcDR5HMtMB4H.Xjo!/r/dFYBAAAAAAAA" alt="logo" title="React native"></p><p>在WebViewApp以及React native均有一个桥接的过程，而在Flutter中使用了Dart语言避免了桥接过程中的性能损耗，从而提升了应用运行的流畅度。</p><ul><li>Hot reload</li></ul><p><img src="https://flutter.io/images/intellij/hot-reload.gif" alt="logo"></p><p>实在是调试一大进步，Android没有开发过，无发言权，但是iOS开发过程中。每次当我们修改一个点，都需要Run一下。而在Hot reload则可以随时修改，在使用Android studio中，只要我们comment + s保存一下，页面就更新了。可以说是非常方便。</p><p>此外还有一个进步如下图,当我们需要调试一个类似朋友圈发布的功能：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/L.cwO7Vd*JcnZONkBc4Eiouz3a0b7RLe.ypc22*ysDw!/r/dEEBAAAAAAAA" alt="logo"></p><p>图中我们可以很明显的看到整个流程的优化。</p><ul><li>其他</li></ul><p>Flutter框架内置一组丰富控件，可以快速开发UI界面，可定制性强，不受限与OEM控件的限制。</p><p>本文主要是进行一些入门的介绍，后续继续添加构建的部分。</p><p>参考(科学上网)：</p><blockquote><footer><strong>什么是Flutter的革命</strong><cite><a href="https://juejin.im/post/5a38e3f651882527a13d9eb2" target="_blank" rel="noopener">juejin.im/post/5a38e3f651882527a13d9eb2</a></cite></footer></blockquote><blockquote><footer><strong>flutter.io</strong><cite><a href="https://flutter.io/" target="_blank" rel="noopener">flutter.io</a></cite></footer></blockquote><blockquote><footer><strong>Two Apps with Flutter and Firebase</strong><cite><a href="https://www.youtube.com/watch?v=w2TcYP8qiRI&t=1107s" target="_blank" rel="noopener">www.youtube.com/watch?v=w2TcYP8qiRI&t=1107s</a></cite></footer></blockquote><blockquote><footer><strong>使用 Flutter 快速构建美观的移动应用</strong><cite><a href="https://www.youtube.com/watch?v=9tQUqOwBpy0" target="_blank" rel="noopener">www.youtube.com/watch?v=9tQUqOwBpy0</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;西班牙巴塞罗那世界移动大会上，Google发布了第一个beta版的Flutter，前前后后也看了一些视频以及讲解。感觉还是比较靠谱的跨平台，最近自己倒腾了一下，才发现开发原来可以这样来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flutter是一个软件开发工具包，可以不过多依赖原系统从而构建高性能，以及高保真的iOS，Android应用程序，在排版布局交互上能够较高的保证用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="flutter" scheme="http://yoursite.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins 2018</title>
    <link href="http://yoursite.com/2018/03/12/Jenkins/"/>
    <id>http://yoursite.com/2018/03/12/Jenkins/</id>
    <published>2018-03-12T01:32:55.000Z</published>
    <updated>2020-10-27T05:55:32.632Z</updated>
    
    <content type="html"><![CDATA[<p>因为人类偷懒天性，所以当发现繁琐重复的操作，就会想办法简化相应的操作。</p><a id="more"></a><p>在没有Jenkins的时候，我们需要打包给测试同学的操作是这样：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/egid1hPFSsFtL2.t19bfmR2pQMk68eE8lwFxQnuQ6Co!/r/dEUBAAAAAAAA" alt="logo"></p><p>在有Jenkins的时候，我们需要打包给测试同学的操作是这样：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/P7zHZYOv1sdQuUcUYv8YYF4nznm.hiPXhJjD8Um00YQ!/r/dEEBAAAAAAAA" alt="logo"></p><p>所以我们可以明显看出，后者效率更高，操作更加简便。接下来记录一下，使用Jenkins的过程，给自己做个备忘，也可以提供参考。</p><blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h4></blockquote><p>本次使用的是SVN + Jenkins 进行简便化操作，首先我们去<a href="https://jenkins.io" target="_blank" rel="noopener"><strong>Jenkins官网</strong></a>下载，其中LTS Release（稳定版），Weekly Release（每周更新版本）没有太大的区别，都可以下载。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/ySupsUW7okNyDfH5xB2iLYCt0SVMk3O74J60RHUiTbc!/r/dEQBAAAAAAAA" alt="logo"></p><p>然后点击下载对应平台的版本。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/kbTcYDdcmHfRMngUGeemzhiiTuNiYbW4rPhM68.BbOg!/r/dEIBAAAAAAAA" alt="logo"></p><p>傻瓜式安装。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/xEw6py1LXnRI1ZLiQTJmRqFGHjv5up3Fvi06dsEfRAU!/r/dEABAAAAAAAA" alt="logo"></p><p>完成后，safari会自动打开<code>http://localhost:8080</code>，如果没有可自行输入。这个时候可能会报这个错。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/dk03bGcGSez3bN1Av1FTsE5xG5crfvDWPcaWzyj.qSc!/r/dPMAAAAAAAAA" alt="logo"></p><p>这是因为我们没有配置Java环境，可以<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener"><strong>点击下载</strong></a>，需要注意一下Java版本，然后傻瓜式安装</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/3YpUy4G.wCZfL7CoVjEts3ibbs11CFkNbYnWhgHN.ds!/r/dPMAAAAAAAAA" alt="logo"></p><p>我们再次打开<code>http://localhost:8080</code>，如果不行，重启一下。重启后我们会发现，mac新增了一个账号，但是现在我们还不知道密码。用safari打开<code>http://localhost:8080</code>，出现这个页面。表明我们的准备工作正式完成。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/h34fhRWLy3yNM1HjpsB.skgnFBpM4CHzhlCJl9XrzK4!/r/dF4BAAAAAAAA" alt="logo"></p><blockquote><h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a><strong>配置准备</strong></h4></blockquote><h5 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a><strong>密码设置</strong></h5><p>我们复制 <code>/Users/Shared/Jenkins/Home</code>，打开Finder，然后<code>Command-Shift-G</code>粘贴刚刚复制的路径。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/J84G0iY7soBKHJYkVBVfGQWrPyB4mCiJ6n4vvunx5iQ!/r/dGgBAAAAAAAA" alt="logo"></p><p>然后修改<code>sercets</code>文件夹访问权限，右击<code>显示简介</code>，点击右下角的锁。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/7K966kuaY*rRja8QLoYFUYmCc8ReHwR1dfCEESeOfW0!/r/dEIBAAAAAAAA" alt="logo"></p><p>输入mac密码后，点击权限栏下面。打开<code>initialAdminPassword</code>文件，如果也是没有权限就按照刚刚的一样，修改访问权限。将<code>initialAdminPassword</code>文件中的密码复制到safari中，点击safari中继续</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/oNRkL7jRIXfLBgUTHbKOtYW86QWtGwFEBtUAhDZyIMY!/r/dFYBAAAAAAAA" alt="logo"></p><p>点击左边，跳转到下面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/zCB*d*.yhcF5DPrJA2jBFECAitS0fAAz*Y6KpXPn.lM!/r/dEEBAAAAAAAA" alt="logo"></p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h5><p>首先我们需要创建一个管理员用户</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/26mhwqrQYAtbdAWppueDNQg25V6lWNbF5*YM39KvNjk!/r/dFsBAAAAAAAA" alt="logo"></p><p>创建成功后，点击跳转到欢迎页面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/RIm.9E0E6lAqqXpfxUZfDfCcob8.kE6Q3PEEJ0XD5jA!/r/dAgBAAAAAAAA" alt="logo"></p><h5 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a><strong>下载插件</strong></h5><p>然后我们安装一些必要的插件</p><p>点击<code>系统管理</code> - <code>插件管理</code> - <code>右上角搜索</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/LgZSPTLGLeVShDnVieixzbatW2Kf.KykK7SrDuopMik!/r/dEMBAAAAAAAA" alt="logo"></p><p>安装成功可在<code>系统管理</code> - <code>插件管理</code> - <code>已安装</code> 中查看</p><ul><li><strong>Xcode integration</strong></li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/CVIOkIwuPF*foMOhNkvyBod*HgbX4E4wS0WZvsyKOIU!/r/dEMBAAAAAAAA" alt="logo"></p><ul><li><strong>Keychains and Provisioning Profiles Management</strong></li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/OiOzoigUwZqyhz4w8ADOG7SqMJqrOEB5akGepVuRqiM!/r/dGgBAAAAAAAA" alt="logo"></p><h5 id="配制插件"><a href="#配制插件" class="headerlink" title="配制插件"></a><strong>配制插件</strong></h5><p>配置插件信息<code>系统管理</code> - <code>系统设置</code> - <code>Xcode Builder</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/Dmv4KFLtpQerC.t34BOmm4i00UOB.TSQtjCWP17vWdo!/r/dFYBAAAAAAAA" alt="logo"></p><p>配置插件信息<code>系统管理</code> - <code>Keychains and Provisioning Profiles Management</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/YDRgUWo4RIkvDtCdxUvHf81Y4ppVqEvBL4aT1WJhjSs!/r/dPIAAAAAAAAA" alt="logo"></p><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h5><p>安装完成后我们创建一个项目</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/hM0UzzzX4PEgNbpda6O58CRxr9pFvtws4Q8RHozy.rI!/r/dFYBAAAAAAAA" alt="logo"></p><ul><li>配置基本信息</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/vMbyrH.co6CQY6aKXHJvi6hjyTXLVINblovFYsAnqrc!/r/dGoBAAAAAAAA" alt="logo"></p><ul><li>源码管理</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/ufSe36YIlOPbffSEfRVhJEQc1G6rieXMrtoCwrqP6Uk!/r/dAgBAAAAAAAA" alt="logo"></p><ul><li>构建环境</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/2By02pf.qqtBBFrN*wBMVg1QzkOY*HRpGwrqXTjo2QY!/r/dEEBAAAAAAAA" alt="logo"></p><ul><li>构建 - General build settings</li></ul><blockquote><p>Target为项目中的target名字、</p><p>Configuration可以设置发布（Release）或测试（Debug）</p><p>.ipa filename pattern为 .ipa打包后的文件名</p><p>Output directory 为.ipa包目录</p></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/Otu2wuxDZbakfjHDr0DVRYnLzoM1Zs7HrhtU3o9qvfo!/r/dFsBAAAAAAAA" alt="logo"></p><ul><li>构建 - Code signing &amp; OS X keychain options</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/4QdKxz7slhcdkp.G6SnkGl8q.x4HyvaDrl1DyV.TKuo!/r/dEIBAAAAAAAA" alt="logo"></p><ul><li>构建 - Advanced Xcode build options</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/KyO3xbHehW90AEq2vbHsX5NMdnLP1p3gBnO8W0ORTrM!/r/dEQBAAAAAAAA" alt="logo"></p><blockquote><h4 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a><strong>构建项目</strong></h4></blockquote><p>配置信息完成之后，跳转到构建页面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/nQPo.iQ.3eQdbdBINmh1tIYxQrytDbafftTXBHElXEo!/r/dFYBAAAAAAAA" alt="logo"></p><p>点击立即构建，等待一段时间后可以打包好项目。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/jDtEYVCy4CJDQAg1LQLgq4n74pdnR1RK5TBlVLu08uc!/r/dEABAAAAAAAA" alt="logo"></p><blockquote><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h4></blockquote><p>“偷懒”是人类发展的“根源”，作为程序员，在编码的工作中，也要时常有这样的思考，优化，重构，封装，才能不断提高等级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为人类偷懒天性，所以当发现繁琐重复的操作，就会想办法简化相应的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>网易严选</title>
    <link href="http://yoursite.com/2018/02/10/yanxuan/"/>
    <id>http://yoursite.com/2018/02/10/yanxuan/</id>
    <published>2018-02-10T06:46:49.000Z</published>
    <updated>2020-11-26T08:19:14.747Z</updated>
    
    <content type="html"><![CDATA[<p>个人对网易出品的应用都比较有好感，网易云音乐，网易严选，蜗牛阅读等，用户体验都是比较好的，用“精致”形容不为过。再加上之前公司的项目详情页面采用的就是像素级别仿照。当然现在网易严选的部分版面又有了调整。因为公司最近没有太多事情，所以就用了几天重新仿写了最新版本的网易严选详情页面，像素级别的仿照。</p><a id="more"></a><blockquote><h4 id="点"><a href="#点" class="headerlink" title="点"></a><strong>点</strong></h4></blockquote><ul><li>页面任意组合布局</li><li>商品图片下拉缩放</li><li>页面上拉动画，滚动页面</li><li>基于UICollectionView换行布局，适用商品多规格选择（服务cell）</li><li>继承，分类，Runtime一键添加控件</li><li>代码精细化，保证各个类中代码行数</li><li>HTML数据抓取</li><li>异步，多线程，KVC数据处理</li><li>交互与严选保持一致</li></ul><blockquote><h4 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h4></blockquote><p><img src="https://raw.githubusercontent.com/sqjuanke/wangyiyanxuan/master/picture/psb03.png" alt="logo"></p><p><img src="https://github.com/hanson1024/wangyiyanxuan/raw/master/picture/psb02.png" alt="logo"></p><p><img src="https://github.com/hanson1024/wangyiyanxuan/raw/master/picture/psb01.png" alt="logo"></p><blockquote><h4 id="构"><a href="#构" class="headerlink" title="构"></a><strong>构</strong></h4></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/Uqu2QawX0RnBGxN8x5V2epX*t65UQZMYR*pqTqWgSVQ!/r/dEQBAAAAAAAA" alt="logo"></p><blockquote><h4 id="待"><a href="#待" class="headerlink" title="待"></a><strong>待</strong></h4></blockquote><ul><li>评论页面跳转</li><li>规格数量选择</li><li>服务详情弹窗</li><li>转发弹窗</li></ul><blockquote><footer><strong>Demo :</strong><cite><a href="https://github.com/sqjuanke/wangyiyanxuan" target="_blank" rel="noopener">github.com/sqjuanke/wangyiyanxuan</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人对网易出品的应用都比较有好感，网易云音乐，网易严选，蜗牛阅读等，用户体验都是比较好的，用“精致”形容不为过。再加上之前公司的项目详情页面采用的就是像素级别仿照。当然现在网易严选的部分版面又有了调整。因为公司最近没有太多事情，所以就用了几天重新仿写了最新版本的网易严选详情页面，像素级别的仿照。&lt;/p&gt;
    
    </summary>
    
      <category term="模仿" scheme="http://yoursite.com/categories/%E6%A8%A1%E4%BB%BF/"/>
    
    
      <category term="网易" scheme="http://yoursite.com/tags/%E7%BD%91%E6%98%93/"/>
    
      <category term="模仿" scheme="http://yoursite.com/tags/%E6%A8%A1%E4%BB%BF/"/>
    
  </entry>
  
  <entry>
    <title>年末2017</title>
    <link href="http://yoursite.com/2017/12/30/2017/"/>
    <id>http://yoursite.com/2017/12/30/2017/</id>
    <published>2017-12-30T06:00:56.000Z</published>
    <updated>2020-11-26T08:03:11.598Z</updated>
    
    <content type="html"><![CDATA[<p>回顾17，迎接18年</p><blockquote><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a><strong>工作</strong></h4></blockquote><p>17年有点类似高产，从16年底到17年底一共完成三款应用的上架，伴随着的是都习惯性的加班，个人的总结少了很多，很多都是业务代码的构写。主要是也是公司的“战略”比较多。</p><p>今年是独立开发的开始，项目中的所有都是自己拿主意。有了更多的自由度，也有了更多的尝试。</p><p>从湖南到广州，工作环境的变化，个人效率也高了不少。</p><a id="more"></a><p><strong>尝试</strong></p><p>小程序也是写了一个Demo就没有下文了，原因也是项目紧，连续几个月的995。。</p><p>机器学习，报了优达学院的入门课程，目前还差P3，P4没有完成。感觉有点打水漂了。</p><p>因为机器学习需要Python，所以陆陆续续学了一段时间，但是由于项目紧又停了一段时间了。</p><blockquote><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a><strong>生活</strong></h4></blockquote><p>结束了晚上回家没有人开灯的情况，虽然两个人都加班比较多。</p><blockquote><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h4></blockquote><p>工作方面，需要更多的总结</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾17，迎接18年&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;&lt;strong&gt;工作&lt;/strong&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;17年有点类似高产，从16年底到17年底一共完成三款应用的上架，伴随着的是都习惯性的加班，个人的总结少了很多，很多都是业务代码的构写。主要是也是公司的“战略”比较多。&lt;/p&gt;
&lt;p&gt;今年是独立开发的开始，项目中的所有都是自己拿主意。有了更多的自由度，也有了更多的尝试。&lt;/p&gt;
&lt;p&gt;从湖南到广州，工作环境的变化，个人效率也高了不少。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Synchronization</title>
    <link href="http://yoursite.com/2017/12/27/synchronization/"/>
    <id>http://yoursite.com/2017/12/27/synchronization/</id>
    <published>2017-12-27T02:09:34.000Z</published>
    <updated>2020-10-27T05:56:18.561Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序中多线程的存在，带来了有关多个执行线程安全访问资源的潜在问题。两个线程修改同一资源可能会以非预期的方式相互干扰。例如，一个线程可能会覆盖另一个线程的修改，或者使应用程序进入一个未知的、潜在的无效状态。如果你很幸运，被破坏的资源可能会导致明显的性能问题或崩溃，而这些问题相对容易跟踪和修复。然而，如果你不幸运，损坏可能会导致微妙的错误，直到很久以后才会表现出来，或者这些错误可能需要对你的底层编码假设进行重大的整改。</p><a id="more"></a><p>当涉及到线程安全时，一个好的设计是你最好的保护。避免共享资源，尽量减少你的线程之间的交互，使得这些线程相互干扰的可能性降低。然而，完全无干扰的设计并不总是可能的。在你的线程必须交互的情况下，你需要使用同步工具来确保当它们交互时，能够安全地进行。</p><p>OSX和iOS提供了许多同步工具供你使用，从提供互斥访问的工具到在你的应用程序中正确排序事件的工具不一而足。下面的章节描述了这些工具，以及您如何在代码中使用它们来影响对程序资源的安全访问。</p><h2 id="Synchronization-Tools"><a href="#Synchronization-Tools" class="headerlink" title="Synchronization Tools"></a><strong>Synchronization Tools</strong></h2><p>为了防止不同的线程意外地改变数据，你可以将你的应用程序设计成不存在同步问题，或者你可以使用同步工具。虽然完全避免同步问题是可取的，但并不总是可能的。下面的章节描述了可供您使用的同步工具的基本类别。</p><h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><p>原子操作是一种简单的同步形式，工作在简单的数据类型上。原子操作的优点是不会阻塞竞争的线程。对于简单的操作，例如增量一个计数器变量，这可以带来比带锁好得多的性能。</p><p>OSX和iOS包含了许多操作，以对32位和64位的值进行基本的数学和逻辑运算。在这些操作中，有比较和交换、测试和设置以及测试和清除操作的原子版本。关于支持的原子操作的列表，请参见/usr/include/libkern/OSAtomic.h头文件，或者参见atomicman页面。</p><h3 id="Memory-Barriers-and-Volatile-Variables"><a href="#Memory-Barriers-and-Volatile-Variables" class="headerlink" title="Memory Barriers and Volatile Variables"></a>Memory Barriers and Volatile Variables</h3><p>为了实现最佳性能，编译器经常会对汇编级指令进行重新排序，以使处理器的指令流水线尽可能满。作为这种优化的一部分，编译器可能会对访问主内存的指令进行重新排序，如果它认为这样做不会产生错误的数据。不幸的是，编译器并不总是能够检测到所有与内存相关的操作。如果看似独立的变量实际上相互影响，编译器优化可能会以错误的顺序更新这些变量，产生潜在的错误结果。</p><p>内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序发生。内存屏障的作用就像栅栏一样，迫使处理器在完成定位在屏障前面的任何加载和存储操作之后，才允许执行定位在屏障之后的加载和存储操作。内存屏障通常用于确保一个线程（但对另一个线程可见）的内存操作总是按照预期的顺序进行。在这种情况下，缺乏内存屏障可能会让其他线程看到看似不可能的结果。(对于一个例子，请参见维基百科中关于内存屏障的条目。)要采用内存屏障，你只需在代码中的适当位置调用OSMemoryBarrier函数即可。</p><p>易失性变量对单个变量应用另一种类型的内存约束。编译器经常通过将变量的值加载到寄存器中来优化代码。对于局部变量，这通常不是问题。然而，如果变量在另一个线程中可见，这样的优化可能会使另一个线程无法注意到对它的任何更改。将volatile关键字应用于一个变量，会迫使编译器在每次使用该变量时从内存中加载它。如果一个变量的值可能随时被外部源改变，而编译器可能无法检测到，你可以将其声明为易失性变量。</p><p>因为内存屏障和易失性变量都会减少编译器可以执行的优化次数，所以应该尽量少用，只在需要的地方使用，以确保正确性。有关使用内存屏障的信息，请参见OSMemoryBarrier手册页。</p><h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>锁是最常用的同步工具之一。你可以使用锁来保护你的代码的关键部分，也就是一次只允许一个线程访问的代码段。例如，一个关键部分可能会操作一个特定的数据结构或使用一些资源，一次最多支持一个客户端。通过在这个部分周围放置一个锁，你可以排除其他线程进行可能影响代码正确性的修改。</p><p>表4-1列出了一些程序员常用的锁。OSX和iOS为这些锁类型中的大多数提供了实现，但不是所有的锁类型。对于不支持的锁类型，描述栏解释了这些锁没有直接在平台上实现的原因。查锁具有潜在的不安全性，系统不对其提供明确的支持，不鼓励使用双重检查锁。</p><p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcZb5uUS4h8juFgPNmXlqNMZO6A3XJpDTRUtDIAVkG8qHQiJx3nYohftoR3sC8st7AabFi*v.vCZfIcZTAhnswKc!/r" alt="logo"></p><p>注意：大多数类型的锁还包含一个内存屏障，以确保任何前面的加载和存储指令在进入关键部分之前完成。</p><p>有关如何使用锁的信息，请参阅使用锁。</p><h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>条件是另一种类型的信号体，它允许线程在某个条件为真时相互发出信号。条件通常用于指示资源的可用性，或者确保任务按照特定的顺序执行。当一个线程测试一个条件时，除非该条件已经为真，否则它就会被阻塞。在其他线程明确改变并发出信号之前，它一直处于阻塞状态。条件和mutex锁的区别在于，可以允许多个线程同时访问条件。条件更像是一个守门人，根据一些指定的标准允许不同的线程通过门。</p><p>使用条件的一种方式是管理一个待处理事件池。事件队列将使用一个条件变量，当队列中有事件时，向等待的线程发出信号。如果有一个事件到达，队列会适当地发出条件信号。如果一个线程已经在等待，它就会被唤醒，然后从队列中提取事件并进行处理。如果有两个事件同时进入队列，队列会发出两次信号来唤醒两个线程。</p><p>系统提供了几种不同技术的条件支持。但是，条件的正确实现需要仔细的编码，所以在自己的代码中使用条件之前，应该先看看《使用条件》中的例子。</p><h3 id="Perform-Selector-Routines"><a href="#Perform-Selector-Routines" class="headerlink" title="Perform Selector Routines"></a>Perform Selector Routines</h3><p>Cocoa应用程序有一种方便的方法，可以将消息以同步的方式传递给单个线程。NSObject类声明了用于在应用程序的一个活动线程上执行选择器的方法。这些方法让你的线程在保证目标线程同步执行消息的情况下，异步地传递消息。例如，你可以使用执行选择器消息将分布式计算的结果传递给你的应用程序的主线程或指定的协调者线程。每个执行选择器的请求都会在目标线程的运行循环上排队，然后按照收到请求的顺序依次处理。</p><p>有关执行选择器例程的摘要和有关如何使用它们的更多信息，请参阅Cocoa执行选择器源。</p><h2 id="Synchronization-Costs-and-Performance"><a href="#Synchronization-Costs-and-Performance" class="headerlink" title="Synchronization Costs and Performance"></a><strong>Synchronization Costs and Performance</strong></h2><p>同步有助于确保代码的正确性，但这样做是以牺牲性能为代价的。使用同步工具会引入延迟，即使在无争议的情况下也是如此。锁和原子操作通常涉及使用内存屏障和内核级同步来确保代码得到适当保护。而如果存在对锁的争夺，你的线程可能会阻塞并经历更大的延迟。</p><p>表4-2列出了一些在无竞争情况下与mutexes和原子操作相关的大致成本。这些测量结果代表了几千个样本的平均时间。不过和线程创建时间一样，mutex的获取时间（即使在无争议的情况下）也会因处理器负载、计算机速度以及可用的系统和程序内存量而有很大差异。</p><p>表4-2互换和原子操作耗费</p><p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth*pXbK3EaXZxBB3Qm1o22JWm6Xex6sY3Nd4JDRJQaWefLFalYVCDEzV5qvIBLRVIHI!/r" alt="logo"></p><p>在设计并发任务时，正确性永远是最重要的因素，但你也应该考虑性能因素。在多线程下正确执行的代码，却比在单线程上运行的相同代码慢，很难说是一种改进。</p><p>如果你正在改造一个现有的单线程应用程序，你应该始终对关键任务的性能进行一组基线测量。在添加额外的线程后，你应该对这些相同的任务进行新的测量，并将多线程情况和单线程情况的性能进行比较。如果在调整代码后，线程并没有提高性能，你可能要重新考虑你的具体实现或完全使用线程。</p><p>关于性能和收集指标的工具的信息，请参见性能概述。关于锁和原子操作的成本的具体信息，请参见线程消耗。</p><h2 id="Thread-Safety-and-Signals"><a href="#Thread-Safety-and-Signals" class="headerlink" title="Thread Safety and Signals"></a><strong>Thread Safety and Signals</strong></h2><p>谈到线程应用，没有什么比处理信号的问题更让人恐惧或困惑。信号是一种低级的BSD机制，可以用来向进程传递信息或以某种方式操纵它。一些程序使用信号来检测某些事件，例如子进程的死亡。系统使用信号来终止失控的进程和传达其他类型的信息。</p><p>信号的问题不在于它们的作用，而是当你的应用程序有多个线程时它们的行为。在单线程应用程序中，所有信号处理程序都运行在主线程上。在多线程应用程序中，不与特定硬件错误（如非法指令）相关联的信号会传递给当时恰好运行的任何一个线程。如果多个线程同时运行，则信号会传递给系统恰好选择的那个线程。换句话说，信号可以传递给应用程序的任何线程。</p><p>在应用程序中实现信号处理程序的第一条规则是避免假设哪个线程在处理信号。如果一个特定的线程想要处理一个给定的信号，你需要想办法在信号到达时通知这个线程。你不能仅仅假设从该线程安装信号处理程序会导致信号被传递到同一个线程。</p><p>关于信号和安装信号处理程序的更多信息，请参见信号和sigaction手册页。</p><h2 id="Tips-for-Thread-Safe-Designs"><a href="#Tips-for-Thread-Safe-Designs" class="headerlink" title="Tips for Thread-Safe Designs"></a><strong>Tips for Thread-Safe Designs</strong></h2><p>同步工具是使你的代码线程安全的有用方法，但它们不是万能的。过度使用锁和其他类型的同步基元，与非线程性能相比，实际上会降低应用程序的线程性能。在安全和性能之间找到正确的平衡点是一门需要经验的艺术。以下章节提供了一些提示，帮助您为应用程序选择适当的同步级别。</p><h3 id="Avoid-Synchronization-Altogether"><a href="#Avoid-Synchronization-Altogether" class="headerlink" title="Avoid Synchronization Altogether"></a>Avoid Synchronization Altogether</h3><p>对于你所从事的任何新项目，甚至对于现有的项目，设计你的代码和数据结构以避免对同步的需求是最好的解决方案。虽然锁和其他同步工具很有用，但它们确实会影响任何应用程序的性能。而且如果整体设计导致特定资源之间的高度争用，你的线程可能会等待更长时间。</p><p>实现并发的最好方法是减少你的并发任务之间的相互作用和相互依赖。如果每个任务都在自己的私有数据集上运行，它就不需要使用锁来保护这些数据。即使在两个任务确实共享一个公共数据集的情况下，你也可以研究如何对该数据集进行分区，或者为每个任务提供自己的副本。当然，复制数据集也是有成本的，所以在做出决定之前，你必须权衡这些成本和同步的成本。</p><h3 id="Understand-the-Limits-of-Synchronization"><a href="#Understand-the-Limits-of-Synchronization" class="headerlink" title="Understand the Limits of Synchronization"></a>Understand the Limits of Synchronization</h3><p>同步工具只有在应用程序中的所有线程一致使用它们时才有效。如果您创建了一个mutex来限制对特定资源的访问，那么您的所有线程在尝试操作该资源之前必须获得相同的mutex。如果不这样做，就会使mutex提供的保护失效，并且是程序员的错误。</p><h3 id="Be-Aware-of-Threats-to-Code-Correctness"><a href="#Be-Aware-of-Threats-to-Code-Correctness" class="headerlink" title="Be Aware of Threats to Code Correctness"></a>Be Aware of Threats to Code Correctness</h3><p>当使用锁和内存屏障时，你应该总是仔细考虑它们在你的代码中的位置。即使是看起来放置得很好的锁，实际上也会让你陷入一种错误的安全感。下面的一系列例子试图通过指出看似无害的代码中的缺陷来说明这个问题。基本前提是，你有一个包含一组不可变对象的可变数组。假设你想调用数组中第一个对象的方法。你可以使用下面的代码来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br></pre></td></tr></table></figure><p>因为数组是可变的，所以数组周围的锁可以防止其他线程修改数组，直到你得到想要的对象。而且因为你所检索的对象本身是不可变的，所以在调用doSomething方法的周围不需要锁。</p><p>不过，前面的例子有一个问题。如果你释放了锁，而另一个线程进来，在你有机会执行doSomething方法之前就从数组中删除了所有对象，会发生什么？在一个没有垃圾回收的应用程序中，你的代码所持有的对象可能会被释放，留下一个指向无效内存地址的Object。为了解决这个问题，你可能会决定简单地重新安排你现有的代码，并在调用doSomething之后释放锁，如这里所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[anObject doSomething];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure><p>通过将doSomething调用移到锁里面，你的代码可以保证当方法被调用时，对象仍然有效。不幸的是，如果doSomething方法执行的时间很长，这可能会导致你的代码长时间保持锁，从而产生性能瓶颈。</p><p>代码的问题并不是关键区域定义得不好，而是没有理解实际问题。真正的问题是内存管理问题，只有在其他线程存在时才会触发。因为它可以被其他线程释放，所以更好的解决方案是在释放锁之前保留一个Object。这个解决方案解决了对象被释放的实际问题，而且不会引入潜在的性能惩罚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[anObject retain];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br><span class="line">[anObject release];</span><br></pre></td></tr></table></figure><p>虽然前面的例子很简单，但确实说明了一个很重要的问题。当涉及到正确性时，你必须考虑到明显的问题之外。内存管理和你的设计的其他方面也可能会因为多线程的存在而受到影响，所以你必须事先考虑到这些问题。此外，你应该始终假设编译器在安全问题上会做最坏的打算。这种意识和警惕性应该可以帮助你避免潜在的问题，并确保你的代码表现正确。</p><p>关于如何使你的程序线程安全的其他例子，请看线程安全总结。</p><h3 id="Watch-Out-for-Deadlocks-and-Livelocks"><a href="#Watch-Out-for-Deadlocks-and-Livelocks" class="headerlink" title="Watch Out for Deadlocks and Livelocks"></a>Watch Out for Deadlocks and Livelocks</h3><p>任何时候，当一个线程试图同时获取一个以上的锁时，都有可能发生死锁。当两个不同的线程持有另一个线程需要的锁，然后试图获取另一个线程持有的锁时，就会发生死锁。其结果是，每个线程都永久阻塞，因为它永远无法获得另一个锁。</p><p>livelock类似于死锁，发生在两个线程争夺同一组资源的时候。在livelock情况下，一个线程放弃它的第一个锁，试图获得第二个锁。一旦它获得了第二个锁，它就会返回并试图再次获得第一个锁。它之所以锁死，是因为它把所有的时间都花在释放一个锁和试图获取另一个锁上，而不是做任何真正的工作。</p><p>避免死锁和活锁情况的最好方法是一次只取一把锁。如果你必须一次获取一个以上的锁，你应该确保其他线程不会尝试做类似的事情。</p><h3 id="Use-Volatile-Variables-Correctly"><a href="#Use-Volatile-Variables-Correctly" class="headerlink" title="Use Volatile Variables Correctly"></a>Use Volatile Variables Correctly</h3><p>如果你已经在使用mutex来保护某段代码，不要自动认为你需要使用volatile关键字来保护该段代码中的重要变量。一个mutex包括一个内存屏障，以确保加载和存储操作的正确顺序。将volatile关键字添加到关键部分内的变量中，会强制每次访问时从内存中加载该值。在特定情况下，这两种同步技术的结合可能是必要的，但也会导致显著的性能惩罚。如果仅用mutex就足以保护变量，请省略volatile关键字。</p><p>同样重要的是，不要为了避免使用mutexes而使用volatile变量。一般来说，mutexes和其他同步机制比volatile变量更能保护你的数据结构的完整性。volatile关键字只确保变量从内存中加载，而不是存储在寄存器中。它不能确保变量被你的代码正确访问。</p><h3 id="Using-Atomic-Operations"><a href="#Using-Atomic-Operations" class="headerlink" title="Using Atomic Operations"></a>Using Atomic Operations</h3><p>非阻塞同步是一种执行某些类型操作并避免锁的费用的方法。虽然锁是同步两个线程的有效方式，但获取锁是一种相对昂贵的操作，即使是在无争议的情况下。相比之下，许多原子操作只需要很少的时间就能完成，而且可以和锁一样有效。</p><p>原子运算让你可以对32位或64位的值进行简单的数学和逻辑运算。这些操作依靠特殊的硬件指令（以及一个可选的内存屏障）来确保给定的操作在受影响的内存被再次访问之前完成。在多线程的情况下，应该始终使用包含内存屏障的原子操作，以确保内存在线程之间正确同步。</p><p>表4-3列出了可用的原子数学和逻辑运算以及相应的函数名称。这些函数都是在/usr/include/libkern/OSAtomic.h头文件中声明的，在那里也可以找到完整的语法。这些函数的64位版本只在64位进程中可用。</p><p>表4-3原子数学和逻辑运算。<br>    <img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth.oOyCkLycLr3mLW2ase4ETPt9xDKYYNKFPXpehZaV3qS1BZPD*20CcbXjXNUFa614!/r" alt=""><br>    <img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth*pZ1VUDRh5gJ46jbtVfVoJ7jtwhu9SOEADPWpanalssBwqmmFIua4Pts7IXpCg2sY!/r" alt=""><br>    大多数原子函数的行为应该是相对简单的，也是你所期望的。然而，清单4-1显示了原子测试和设置以及比较和交换操作的行为，这些操作要复杂一些。对OSAtomicTestAndSet函数的前三次调用展示了在整数值上使用的位操作公式及其结果如何与你所期望的不同。最后两次调用展示了OSAtomicCompareAndSwap32函数的行为。在所有情况下，这些函数都是在无争议的情况下被调用的，当时没有其他线程在操作这些值。<br>    清单4-1执行原子操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32_t  theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(0, &amp;theValue);</span><br><span class="line">// theValue is now 128.</span><br><span class="line"> </span><br><span class="line">theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(7, &amp;theValue);</span><br><span class="line">// theValue is now 1.</span><br><span class="line"> </span><br><span class="line">theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(15, &amp;theValue)</span><br><span class="line">// theValue is now 256.</span><br><span class="line"> </span><br><span class="line">OSAtomicCompareAndSwap32(256, 512, &amp;theValue);</span><br><span class="line">// theValue is now 512.</span><br><span class="line"> </span><br><span class="line">OSAtomicCompareAndSwap32(256, 1024, &amp;theValue);</span><br><span class="line">// theValue is still 512.</span><br></pre></td></tr></table></figure><p>关于原子操作的信息，请参见atomicman页面和/usr/include/libkern/OSAtomic.h头文件。</p><h2 id="Using-Locks"><a href="#Using-Locks" class="headerlink" title="Using Locks"></a><strong>Using Locks</strong></h2><p>锁是线程编程的基本同步工具。锁使你能够轻松地保护大段代码，从而保证代码的正确性。OSX和iOS为所有应用类型提供了基本的mutex锁，Foundation框架为特殊情况定义了一些额外的mutex锁变体。下面的章节将向您展示如何使用其中的几种锁类型。</p><h3 id="Using-a-POSIX-Mutex-Lock"><a href="#Using-a-POSIX-Mutex-Lock" class="headerlink" title="Using a POSIX Mutex Lock"></a>Using a POSIX Mutex Lock</h3><p>POSIX的mutex锁在任何应用程序中都非常容易使用。要创建mutex锁，你需要声明并初始化一个pthread_mutex_t结构。要锁定和解锁mutex锁，需要使用pthread_mutex_lock和pthread_mutex_unlock函数。清单4-2显示了初始化和使用POSIX线程mutex锁所需的基本代码。当你使用完锁后，只需调用pthread_mutex_destroy来释放锁的数据结构。</p><p>清单4-2使用mutex锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mutex;</span><br><span class="line">void MyInitFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyLockingFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    // Do work.</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：前面的代码是一个简化的例子，旨在展示POSIX线程mutex函数的基本用法。你自己的代码应该检查这些函数返回的错误代码，并适当地处理它们。</p><h3 id="Using-the-NSLock-Class"><a href="#Using-the-NSLock-Class" class="headerlink" title="Using the NSLock Class"></a>Using the NSLock Class</h3><p>NSLock对象为Cocoa应用程序实现了一个基本的mutex。所有锁（包括NSLock）的接口实际上是由NSLocking协议定义的，它定义了锁和解锁方法。您使用这些方法来获取和释放锁，就像您使用任何mutex一样。</p><p>除了标准的锁定行为，NSLock类还增加了tryLock和lockBeforeDate:方法。tryLock方法试图获取锁，但如果锁不可用，则不会阻塞；相反，该方法只返回NO。lockBeforeDate:方法试图获取锁，但如果在指定的时间限制内没有获取锁，则会解锁线程（并返回NO）。</p><p>下面的例子显示了如何使用NSLock对象来协调一个可视化显示器的更新，该显示器的数据正由多个线程计算。如果线程不能立即获取锁，它只是继续计算，直到它能获取锁并更新显示屏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL moreToDo = YES;</span><br><span class="line">NSLock *theLock = [[NSLock alloc] init];</span><br><span class="line">...</span><br><span class="line">while (moreToDo) &#123;</span><br><span class="line">    /* Do another increment of calculation */</span><br><span class="line">    /* until there’s no more to do. */</span><br><span class="line">    if ([theLock tryLock]) &#123;</span><br><span class="line">        /* Update display used by all threads. */</span><br><span class="line">        [theLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-the-synchronized-Directive"><a href="#Using-the-synchronized-Directive" class="headerlink" title="Using the @synchronized Directive"></a>Using the @synchronized Directive</h3><p>@synchronized指令是在Objective-C代码中创建mutex锁的便捷方式。@synchronized指令的作用和其他mutex锁一样–它可以防止不同的线程在同一时间获取同一个锁。然而，在这种情况下，您不必直接创建mutex或锁对象。取而代之的是，您只需使用任何Objective-C对象作为锁标记，如下例所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj</span><br><span class="line">&#123;</span><br><span class="line">    @synchronized(anObj)</span><br><span class="line">    &#123;</span><br><span class="line">        // Everything between the braces is protected by the @synchronized directive.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给@synchronized指令的对象是一个唯一的标识符，用来区分保护块。如果在两个不同的线程中执行前面的方法，在每个线程上为anObj参数传递一个不同的对象，每个线程都会取得它的锁并继续处理，而不会被另一个线程阻塞。然而，如果在两种情况下传递相同的对象，其中一个线程将首先取得锁，另一个线程将阻塞，直到第一个线程完成关键部分。<br>    作为一种预防措施，@synchronizedblock隐含地在保护代码中添加了一个异常处理程序。这个处理程序会在抛出异常的情况下自动释放mutex。这意味着为了使用@synchronized指令，你必须在你的代码中启用Objective-C异常处理。如果你不想要隐式异常处理程序造成的额外开销，你应该考虑使用锁类。<br>    有关@synchronized指令的更多信息，请参阅Objective-C编程语言。</p><h3 id="Using-Other-Cocoa-Locks"><a href="#Using-Other-Cocoa-Locks" class="headerlink" title="Using Other Cocoa Locks"></a>Using Other Cocoa Locks</h3><p>下面的章节描述了使用其他几种类型的Cocoa锁的过程。</p><h3 id="Using-an-NSRecursiveLock-Object"><a href="#Using-an-NSRecursiveLock-Object" class="headerlink" title="Using an NSRecursiveLock Object"></a>Using an NSRecursiveLock Object</h3><p>NSRecursiveLock类定义了一个可以被同一线程多次获取而不会导致线程死锁的锁。递归锁会跟踪它被成功获取的次数。每次成功获取锁的时候，必须有一个相应的调用来平衡解锁。只有当所有的锁和解锁调用都被平衡时，锁才会被真正释放，以便其他线程可以获取它。</p><p>顾名思义，这种类型的锁通常用于递归函数内部，以防止递归阻塞线程。在非递归的情况下，你同样可以用它来调用那些语义上要求它们也获取锁的函数。下面是一个简单的递归函数的例子，它通过递归获取锁。如果你没有在这段代码中使用NSRecursiveLock对象，当函数再次被调用时，线程就会死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];</span><br><span class="line"> </span><br><span class="line">void MyRecursiveFunction(int value)</span><br><span class="line">&#123;</span><br><span class="line">    [theLock lock];</span><br><span class="line">    if (value != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        --value;</span><br><span class="line">        MyRecursiveFunction(value);</span><br><span class="line">    &#125;</span><br><span class="line">    [theLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyRecursiveFunction(5);</span><br></pre></td></tr></table></figure><p>注意：由于递归锁在所有锁调用与解锁调用平衡之前不会被释放，因此您应该仔细权衡使用性能锁的决定与潜在的性能影响。长时间保持任何锁都会导致其他线程阻塞，直到递归完成。如果你能重写你的代码以消除递归或消除使用递归锁的需要，你可能会获得更好的性能。</p><h3 id="Using-an-NSConditionLock-Object"><a href="#Using-an-NSConditionLock-Object" class="headerlink" title="Using an NSConditionLock Object"></a>Using an NSConditionLock Object</h3><p>NSConditionLock对象定义了一个mutex锁，它可以用特定的值进行锁定和解锁。您不应该将这种类型的锁与条件混淆起来（参见条件）。其行为与条件有些类似，但实现方式非常不同。<br>    通常情况下，当线程需要按照特定的顺序执行任务时，例如当一个线程生产数据，另一个线程消费数据时，您会使用NSConditionLock对象。当生产者在执行时，消费者使用一个特定于你的程序的条件来获取锁。(条件本身只是一个您定义的整数值。)当生产者完成时，它解锁并将锁条件设置为适当的整数值，以唤醒消费者线程，然后继续处理数据。<br>    NSConditionLock对象响应的锁定和解锁方法可以任意组合使用。例如，你可以将锁定消息与unlockWithCondition:配对，或者将lockWhenCondition:消息与解锁配对。当然，后一种组合可以解锁锁，但可能不会释放任何等待特定条件值的线程。<br>    下面的例子展示了如何使用条件锁来处理生产者-消费者问题。想象一下，一个应用程序包含一个数据队列。生产者线程向队列添加数据，消费者线程从队列中提取数据。生产者不需要等待特定的条件，但它必须等待锁可用，这样它才能安全地将数据添加到队列中。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    [condLock lock];</span><br><span class="line">    /* Add data to the queue. */</span><br><span class="line">    [condLock   unlockWithCondition:HAS_DATA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>因为锁的初始条件被设置为NO_DATA，所以生产者线程最初获取锁应该没有问题。它用数据填充队列，并将条件设置为HAS_DATA。在随后的迭代过程中，生产者线程可以在新数据到达时添加新数据，不管队列是空的还是还有一些数据。唯一的一次阻塞是当消费者线程从队列中提取数据的时候。<br>    因为消费线程必须有数据要处理，所以它使用特定的条件在队列上等待。当生产者将数据放在队列上时，消费线程就会被唤醒并获得它的锁。然后，它可以从队列中提取一些数据并更新队列状态。下面的例子显示了消费者线程处理循环的基本结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    while (true)&#123;</span><br><span class="line">    [condLock lockWhenCondition:HAS_DATA];</span><br><span class="line">    /* Remove data from the queue. */</span><br><span class="line">    [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)];</span><br><span class="line">    // Process the data locally.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-an-NSDistributedLock-Object"><a href="#Using-an-NSDistributedLock-Object" class="headerlink" title="Using an NSDistributedLock Object"></a>Using an NSDistributedLock Object</h3><p>NSDistributedLock类可以被多个主机上的多个应用程序用来限制对某些共享资源的访问，比如文件。锁本身实际上是一个mutex锁，它是使用文件系统项（如文件或目录）实现的。为了使NSDistributedLock对象可以使用，该锁必须可以被所有使用它的应用程序写入。这通常意味着把它放在一个文件系统上，所有运行该应用程序的计算机都可以访问。<br>    与其他类型的锁不同，NSDistributedLock不符合NSLocking协议，因此没有锁方法。锁定方法会阻止线程的执行，并要求系统以预定的速度轮询锁。NSDistributedLock没有将这种惩罚强加在你的代码上，而是提供了一个tryLock方法，让你决定是否轮询。<br>    因为它是使用文件系统实现的，一个NSDistributedLock对象不会被释放，除非所有者明确释放它。如果您的应用程序在持有分布式锁时崩溃，其他客户端将无法访问受保护的资源。在这种情况下，你可以使用breakLock方法来打破现有的锁，这样你就可以获得它。不过一般来说，应该避免破坏锁，除非你确定拥有锁的进程死亡，无法释放锁。<br>    和其他类型的锁一样，当你使用完一个NSDistributedLock对象后，你可以通过调用unlock方法来释放它。</p><h2 id="Using-Conditions"><a href="#Using-Conditions" class="headerlink" title="Using Conditions"></a><strong>Using Conditions</strong></h2><p>条件锁是一种特殊类型的锁，你可以用它来同步操作必须进行的顺序。它们与mutex锁有细微的不同。在条件锁上等待的线程会一直被阻塞，直到另一个线程明确地发出信号。<br>    由于实现操作系统的微妙之处，条件锁被允许以虚假的成功返回，即使它们实际上没有被你的代码发出信号。为了避免这些虚假信号引起的问题，你应该总是使用一个谓词与你的条件锁一起使用。谓词是确定线程是否安全进行的更具体的方法。条件只是让你的线程保持睡眠状态，直到信号线程可以设置谓词。<br>    下面的章节将向你展示如何在你的代码中使用条件。</p><h3 id="Using-the-NSCondition-Class"><a href="#Using-the-NSCondition-Class" class="headerlink" title="Using the NSCondition Class"></a>Using the NSCondition Class</h3><p>iNSCondition类提供了与POSIX条件相同的语义，但将所需的锁和条件数据结构封装在一个对象中。其结果是一个对象，您可以像mutex一样锁定，然后像条件一样等待。<br>    清单4-3显示了一个代码片段，演示了等待NSCondition对象的事件序列。cocoaCondition变量包含一个NSCondition对象，而timeToDoWork变量则是一个整数，它在发出条件信号之前从另一个线程中增量。<br>清单4-3使用Cocoa条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[cocoaCondition lock];</span><br><span class="line">while (timeToDoWork &lt;= 0)</span><br><span class="line">    [cocoaCondition wait];</span><br><span class="line"> </span><br><span class="line">timeToDoWork--;</span><br><span class="line"> </span><br><span class="line">// Do real work here.</span><br><span class="line"> </span><br><span class="line">[cocoaCondition unlock];</span><br></pre></td></tr></table></figure><p>清单4-4显示了用来给Cocoa条件发信号和递增谓词变量的代码。在发出信号之前，您应该始终锁定条件。<br>清单4-4SignalingaCocoa条件信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[cocoaCondition lock];</span><br><span class="line">timeToDoWork++;</span><br><span class="line">[cocoaCondition signal];</span><br><span class="line">[cocoaCondition unlock];</span><br></pre></td></tr></table></figure><h3 id="Using-POSIX-Conditions"><a href="#Using-POSIX-Conditions" class="headerlink" title="Using POSIX Conditions"></a>Using POSIX Conditions</h3><p>POSIX线程条件锁需要同时使用条件数据结构和mutex。虽然这两个锁结构是分开的，但在运行时，mutex锁与条件结构紧密相连。等待信号的线程应该始终一起使用相同的mutex锁和条件结构。改变配对会导致错误。<br>    清单4-5显示了条件和谓词的基本初始化和用法。在初始化条件和mutex锁后，等待线程进入一个while循环，使用ready_to_go变量作为其谓词。只有当谓词被设置且条件随后被发出信号时，等待线程才会被唤醒并开始做它的工作。<br>清单4-5使用POSIX条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">Boolean     ready_to_go = true;</span><br><span class="line"> </span><br><span class="line">void MyCondInitFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex);</span><br><span class="line">    pthread_cond_init(&amp;condition, NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyWaitOnConditionFunction()</span><br><span class="line">&#123;</span><br><span class="line">    // Lock the mutex.</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">    // If the predicate is already set, then the while loop is bypassed;</span><br><span class="line">    // otherwise, the thread sleeps until the predicate is set.</span><br><span class="line">    while(ready_to_go == false)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Do work. (The mutex should stay locked.)</span><br><span class="line"> </span><br><span class="line">    // Reset the predicate and release the mutex.</span><br><span class="line">    ready_to_go = false;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号线程既要负责设置谓词，又要负责向条件锁发送信号。清单4-6显示了实现这种行为的代码。在这个例子中，条件是在mutex内部发出信号的，以防止在等待条件的线程之间发生竞赛条件。<br>清单4-6给条件锁发送信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void SignalThreadUsingCondition()</span><br><span class="line">&#123;</span><br><span class="line">    // At this point, there should be work for the other thread to do.</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready_to_go = true;</span><br><span class="line"> </span><br><span class="line">    // Signal the other thread to begin work.</span><br><span class="line">    pthread_cond_signal(&amp;condition);</span><br><span class="line"> </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：前面的代码是一个简化的例子，旨在展示POSIX线程条件函数的基本用法。你自己的代码应该检查这些函数返回的错误代码，并适当地处理它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序中多线程的存在，带来了有关多个执行线程安全访问资源的潜在问题。两个线程修改同一资源可能会以非预期的方式相互干扰。例如，一个线程可能会覆盖另一个线程的修改，或者使应用程序进入一个未知的、潜在的无效状态。如果你很幸运，被破坏的资源可能会导致明显的性能问题或崩溃，而这些问题相对容易跟踪和修复。然而，如果你不幸运，损坏可能会导致微妙的错误，直到很久以后才会表现出来，或者这些错误可能需要对你的底层编码假设进行重大的整改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
