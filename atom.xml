<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sqjuanke</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-03T01:38:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter 初识</title>
    <link href="http://yoursite.com/2018/03/28/flutter/"/>
    <id>http://yoursite.com/2018/03/28/flutter/</id>
    <published>2018-03-28T08:05:21.000Z</published>
    <updated>2018-11-03T01:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/b1.Mj01AIZ7j50YRpCikOKAlVg3rGHNO2xGWCMrK5sk!/r/dEQBAAAAAAAA" alt="."></p><blockquote><p>西班牙巴塞罗那世界移动大会上，Google发布了第一个beta版的Flutter，前前后后也看了一些视频以及讲解。感觉还是比较靠谱的跨平台，最近自己倒腾了一下，才发现开发原来可以这样来。</p></blockquote><p>Flutter是一个软件开发工具包，可以不过多依赖原系统从而构建高性能，以及高保真的iOS，Android应用程序，在排版布局交互上能够较高的保证用户体验。</p><a id="more"></a><p>我们先来看看几个亮点</p><ul><li>跨平台</li></ul><p>这个是最主要的亮点，也是Flutter得以发展的根基，无论是开发者，还是老板都希望一个人可以解决前端的所有工作，而不是iOS，Android，前端。当然现在很多再强调大前端，但其实只能说是一个人得需要具备多门技术。而Flutter则只需要一套代码就可以同时运行在两个端，当然有人会提到RN，也是可以完成跨平台，但其构建机制其实是基于原系统的UI进行“封装”，并不能算是完整意义上的跨平台。</p><p>相对于nativeApp, webviewApp, React native的区别我们可以看几个对比图</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/LlVYHz1x5wqQC5i4uEKcgCKCSMYO5Hs9nxCw7VLpu6k!/r/dJEAAAAAAAAA" alt="logo" title="NativeApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/2*IYhakRVUVMOJp8fN*nImpLNKaUzRO.JFCN.hR8Jz4!/r/dEIBAAAAAAAA" alt="logo" title="FlutterApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/sR50fd*l.QWTumAEa8Cp92oM6UuD6kiZx95VdcKLQPc!/r/dGoBAAAAAAAA" alt="logo" title="WebviewApp"></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/Ld0Z8i91poM.STZ26MvWnyCNUv.JcDR5HMtMB4H.Xjo!/r/dFYBAAAAAAAA" alt="logo" title="React native"></p><p>在WebViewApp以及React native均有一个桥接的过程，而在Flutter中使用了Dart语言避免了桥接过程中的性能损耗，从而提升了应用运行的流畅度。</p><ul><li>Hot reload</li></ul><p><img src="https://flutter.io/images/intellij/hot-reload.gif" alt="logo"></p><p>实在是调试一大进步，Android没有开发过，无发言权，但是iOS开发过程中。每次当我们修改一个点，都需要Run一下。而在Hot reload则可以随时修改，在使用Android studio中，只要我们comment + s保存一下，页面就更新了。可以说是非常方便。</p><p>此外还有一个进步如下图,当我们需要调试一个类似朋友圈发布的功能：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/L.cwO7Vd*JcnZONkBc4Eiouz3a0b7RLe.ypc22*ysDw!/r/dEEBAAAAAAAA" alt="logo"></p><p>图中我们可以很明显的看到整个流程的优化。</p><ul><li>其他</li></ul><p>Flutter框架内置一组丰富控件，可以快速开发UI界面，可定制性强，不受限与OEM控件的限制。</p><p>本文主要是进行一些入门的介绍，后续继续添加构建的部分。</p><p>参考(科学上网)：</p><blockquote><footer><strong>什么是Flutter的革命</strong><cite><a href="https://juejin.im/post/5a38e3f651882527a13d9eb2" target="_blank" rel="noopener">juejin.im/post/5a38e3f651882527a13d9eb2</a></cite></footer></blockquote><blockquote><footer><strong>flutter.io</strong><cite><a href="https://flutter.io/" target="_blank" rel="noopener">flutter.io</a></cite></footer></blockquote><blockquote><footer><strong>Two Apps with Flutter and Firebase</strong><cite><a href="https://www.youtube.com/watch?v=w2TcYP8qiRI&t=1107s" target="_blank" rel="noopener">www.youtube.com/watch?v=w2TcYP8qiRI&t=1107s</a></cite></footer></blockquote><blockquote><footer><strong>使用 Flutter 快速构建美观的移动应用</strong><cite><a href="https://www.youtube.com/watch?v=9tQUqOwBpy0" target="_blank" rel="noopener">www.youtube.com/watch?v=9tQUqOwBpy0</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psb?/V12RuddS2GfR1A/b1.Mj01AIZ7j50YRpCikOKAlVg3rGHNO2xGWCMrK5sk!/r/dEQBAAAAAAAA&quot; alt=&quot;.&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;西班牙巴塞罗那世界移动大会上，Google发布了第一个beta版的Flutter，前前后后也看了一些视频以及讲解。感觉还是比较靠谱的跨平台，最近自己倒腾了一下，才发现开发原来可以这样来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flutter是一个软件开发工具包，可以不过多依赖原系统从而构建高性能，以及高保真的iOS，Android应用程序，在排版布局交互上能够较高的保证用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="flutter" scheme="http://yoursite.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
      <category term="跨平台" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins 2018</title>
    <link href="http://yoursite.com/2018/03/12/Jenkins/"/>
    <id>http://yoursite.com/2018/03/12/Jenkins/</id>
    <published>2018-03-12T01:32:55.000Z</published>
    <updated>2018-03-26T01:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/pQksX8SDtjHAMSrAsP6kMNWN5zrwBfZGy2OotkcODhI!/r/dGoBAAAAAAAA" alt="logo"></p><p>因为人类偷懒天性，所以当发现繁琐重复的操作，就会想办法简化相应的操作。</p><a id="more"></a><p>在没有Jenkins的时候，我们需要打包给测试同学的操作是这样：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/egid1hPFSsFtL2.t19bfmR2pQMk68eE8lwFxQnuQ6Co!/r/dEUBAAAAAAAA" alt="logo"></p><p>在有Jenkins的时候，我们需要打包给测试同学的操作是这样：</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/P7zHZYOv1sdQuUcUYv8YYF4nznm.hiPXhJjD8Um00YQ!/r/dEEBAAAAAAAA" alt="logo"></p><p>所以我们可以明显看出，后者效率更高，操作更加简便。接下来记录一下，使用Jenkins的过程，给自己做个备忘，也可以提供参考。</p><blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h4></blockquote><p>本次使用的是SVN + Jenkins 进行简便化操作，首先我们去<a href="https://jenkins.io" target="_blank" rel="noopener"><strong>Jenkins官网</strong></a>下载，其中LTS Release（稳定版），Weekly Release（每周更新版本）没有太大的区别，都可以下载。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/ySupsUW7okNyDfH5xB2iLYCt0SVMk3O74J60RHUiTbc!/r/dEQBAAAAAAAA" alt="logo"></p><p>然后点击下载对应平台的版本。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/kbTcYDdcmHfRMngUGeemzhiiTuNiYbW4rPhM68.BbOg!/r/dEIBAAAAAAAA" alt="logo"></p><p>傻瓜式安装。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/xEw6py1LXnRI1ZLiQTJmRqFGHjv5up3Fvi06dsEfRAU!/r/dEABAAAAAAAA" alt="logo"></p><p>完成后，safari会自动打开<code>http://localhost:8080</code>，如果没有可自行输入。这个时候可能会报这个错。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/dk03bGcGSez3bN1Av1FTsE5xG5crfvDWPcaWzyj.qSc!/r/dPMAAAAAAAAA" alt="logo"></p><p>这是因为我们没有配置Java环境，可以<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener"><strong>点击下载</strong></a>，需要注意一下Java版本，然后傻瓜式安装</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/3YpUy4G.wCZfL7CoVjEts3ibbs11CFkNbYnWhgHN.ds!/r/dPMAAAAAAAAA" alt="logo"></p><p>我们再次打开<code>http://localhost:8080</code>，如果不行，重启一下。重启后我们会发现，mac新增了一个账号，但是现在我们还不知道密码。用safari打开<code>http://localhost:8080</code>，出现这个页面。表明我们的准备工作正式完成。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/h34fhRWLy3yNM1HjpsB.skgnFBpM4CHzhlCJl9XrzK4!/r/dF4BAAAAAAAA" alt="logo"></p><blockquote><h4 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a><strong>配置准备</strong></h4></blockquote><h5 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a><strong>密码设置</strong></h5><p>我们复制 <code>/Users/Shared/Jenkins/Home</code>，打开Finder，然后<code>Command-Shift-G</code>粘贴刚刚复制的路径。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/J84G0iY7soBKHJYkVBVfGQWrPyB4mCiJ6n4vvunx5iQ!/r/dGgBAAAAAAAA" alt="logo"></p><p>然后修改<code>sercets</code>文件夹访问权限，右击<code>显示简介</code>，点击右下角的锁。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/7K966kuaY*rRja8QLoYFUYmCc8ReHwR1dfCEESeOfW0!/r/dEIBAAAAAAAA" alt="logo"></p><p>输入mac密码后，点击权限栏下面。打开<code>initialAdminPassword</code>文件，如果也是没有权限就按照刚刚的一样，修改访问权限。将<code>initialAdminPassword</code>文件中的密码复制到safari中，点击safari中继续</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/oNRkL7jRIXfLBgUTHbKOtYW86QWtGwFEBtUAhDZyIMY!/r/dFYBAAAAAAAA" alt="logo"></p><p>点击左边，跳转到下面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/zCB*d*.yhcF5DPrJA2jBFECAitS0fAAz*Y6KpXPn.lM!/r/dEEBAAAAAAAA" alt="logo"></p><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h5><p>首先我们需要创建一个管理员用户</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/26mhwqrQYAtbdAWppueDNQg25V6lWNbF5*YM39KvNjk!/r/dFsBAAAAAAAA" alt="logo"></p><p>创建成功后，点击跳转到欢迎页面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/RIm.9E0E6lAqqXpfxUZfDfCcob8.kE6Q3PEEJ0XD5jA!/r/dAgBAAAAAAAA" alt="logo"></p><h5 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a><strong>下载插件</strong></h5><p>然后我们安装一些必要的插件</p><p>点击<code>系统管理</code> - <code>插件管理</code> - <code>右上角搜索</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/LgZSPTLGLeVShDnVieixzbatW2Kf.KykK7SrDuopMik!/r/dEMBAAAAAAAA" alt="logo"></p><p>安装成功可在<code>系统管理</code> - <code>插件管理</code> - <code>已安装</code> 中查看</p><ul><li><strong>Xcode integration</strong></li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/CVIOkIwuPF*foMOhNkvyBod*HgbX4E4wS0WZvsyKOIU!/r/dEMBAAAAAAAA" alt="logo"></p><ul><li><strong>Keychains and Provisioning Profiles Management</strong></li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/OiOzoigUwZqyhz4w8ADOG7SqMJqrOEB5akGepVuRqiM!/r/dGgBAAAAAAAA" alt="logo"></p><h5 id="配制插件"><a href="#配制插件" class="headerlink" title="配制插件"></a><strong>配制插件</strong></h5><p>配置插件信息<code>系统管理</code> - <code>系统设置</code> - <code>Xcode Builder</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/Dmv4KFLtpQerC.t34BOmm4i00UOB.TSQtjCWP17vWdo!/r/dFYBAAAAAAAA" alt="logo"></p><p>配置插件信息<code>系统管理</code> - <code>Keychains and Provisioning Profiles Management</code></p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/YDRgUWo4RIkvDtCdxUvHf81Y4ppVqEvBL4aT1WJhjSs!/r/dPIAAAAAAAAA" alt="logo"></p><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h5><p>安装完成后我们创建一个项目</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/hM0UzzzX4PEgNbpda6O58CRxr9pFvtws4Q8RHozy.rI!/r/dFYBAAAAAAAA" alt="logo"></p><ul><li>配置基本信息</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/vMbyrH.co6CQY6aKXHJvi6hjyTXLVINblovFYsAnqrc!/r/dGoBAAAAAAAA" alt="logo"></p><ul><li>源码管理</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/ufSe36YIlOPbffSEfRVhJEQc1G6rieXMrtoCwrqP6Uk!/r/dAgBAAAAAAAA" alt="logo"></p><ul><li>构建环境</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/2By02pf.qqtBBFrN*wBMVg1QzkOY*HRpGwrqXTjo2QY!/r/dEEBAAAAAAAA" alt="logo"></p><ul><li>构建 - General build settings</li></ul><blockquote><p>Target为项目中的target名字、</p><p>Configuration可以设置发布（Release）或测试（Debug）</p><p>.ipa filename pattern为 .ipa打包后的文件名</p><p>Output directory 为.ipa包目录</p></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/Otu2wuxDZbakfjHDr0DVRYnLzoM1Zs7HrhtU3o9qvfo!/r/dFsBAAAAAAAA" alt="logo"></p><ul><li>构建 - Code signing &amp; OS X keychain options</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/4QdKxz7slhcdkp.G6SnkGl8q.x4HyvaDrl1DyV.TKuo!/r/dEIBAAAAAAAA" alt="logo"></p><ul><li>构建 - Advanced Xcode build options</li></ul><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/KyO3xbHehW90AEq2vbHsX5NMdnLP1p3gBnO8W0ORTrM!/r/dEQBAAAAAAAA" alt="logo"></p><blockquote><h4 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a><strong>构建项目</strong></h4></blockquote><p>配置信息完成之后，跳转到构建页面</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/nQPo.iQ.3eQdbdBINmh1tIYxQrytDbafftTXBHElXEo!/r/dFYBAAAAAAAA" alt="logo"></p><p>点击立即构建，等待一段时间后可以打包好项目。</p><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/jDtEYVCy4CJDQAg1LQLgq4n74pdnR1RK5TBlVLu08uc!/r/dEABAAAAAAAA" alt="logo"></p><blockquote><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h4></blockquote><p>“偷懒”是人类发展的“根源”，作为程序员，在编码的工作中，也要时常有这样的思考，优化，重构，封装，才能不断提高等级。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psb?/V12RuddS3FRIrF/pQksX8SDtjHAMSrAsP6kMNWN5zrwBfZGy2OotkcODhI!/r/dGoBAAAAAAAA&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为人类偷懒天性，所以当发现繁琐重复的操作，就会想办法简化相应的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>网易严选</title>
    <link href="http://yoursite.com/2018/02/10/yanxuan/"/>
    <id>http://yoursite.com/2018/02/10/yanxuan/</id>
    <published>2018-02-10T06:46:49.000Z</published>
    <updated>2020-10-27T05:45:49.619Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/AU3HrtMHlW5WZviucq5oB.vXaCcBUkgjcH0tuPv6FZw!/r/dEIBAAAAAAAA" alt="logo"></p><p>个人对网易出品的应用都比较有好感，网易云音乐，网易严选，蜗牛阅读等，用户体验都是比较好的，用“精致”形容不为过。再加上之前公司的项目详情页面采用的就是像素级别仿照。当然现在网易严选的部分版面又有了调整。因为公司最近没有太多事情，所以就用了几天重新仿写了最新版本的网易严选详情页面，像素级别的仿照。</p><a id="more"></a><blockquote><h4 id="点"><a href="#点" class="headerlink" title="点"></a><strong>点</strong></h4></blockquote><ul><li>页面任意组合布局</li><li>商品图片下拉缩放</li><li>页面上拉动画，滚动页面</li><li>基于UICollectionView换行布局，适用商品多规格选择（服务cell）</li><li>继承，分类，Runtime一键添加控件</li><li>代码精细化，保证各个类中代码行数</li><li>HTML数据抓取</li><li>异步，多线程，KVC数据处理</li><li>交互与严选保持一致</li></ul><blockquote><h4 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h4></blockquote><p><img src="http://wx2.sinaimg.cn/large/64c125d7gy1fpgwgf58fcg20a00jnhe0.gif" alt="logo"></p><blockquote><h4 id="构"><a href="#构" class="headerlink" title="构"></a><strong>构</strong></h4></blockquote><p><img src="http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/Uqu2QawX0RnBGxN8x5V2epX*t65UQZMYR*pqTqWgSVQ!/r/dEQBAAAAAAAA" alt="logo"></p><blockquote><h4 id="待"><a href="#待" class="headerlink" title="待"></a><strong>待</strong></h4></blockquote><ul><li>评论页面跳转</li><li>规格数量选择</li><li>服务详情弹窗</li><li>转发弹窗</li></ul><blockquote><footer><strong>Demo:</strong><cite><a href="https://github.com/hanson1024/wangyiyanxuan" target="_blank" rel="noopener">github.com/hanson1024/wangyiyanxuan</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/AU3HrtMHlW5WZviucq5oB.vXaCcBUkgjcH0tuPv6FZw!/r/dEIBAAAAAAAA&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;个人对网易出品的应用都比较有好感，网易云音乐，网易严选，蜗牛阅读等，用户体验都是比较好的，用“精致”形容不为过。再加上之前公司的项目详情页面采用的就是像素级别仿照。当然现在网易严选的部分版面又有了调整。因为公司最近没有太多事情，所以就用了几天重新仿写了最新版本的网易严选详情页面，像素级别的仿照。&lt;/p&gt;
    
    </summary>
    
      <category term="模仿" scheme="http://yoursite.com/categories/%E6%A8%A1%E4%BB%BF/"/>
    
    
      <category term="网易" scheme="http://yoursite.com/tags/%E7%BD%91%E6%98%93/"/>
    
      <category term="模仿" scheme="http://yoursite.com/tags/%E6%A8%A1%E4%BB%BF/"/>
    
  </entry>
  
  <entry>
    <title>年末2017</title>
    <link href="http://yoursite.com/2017/12/30/2017/"/>
    <id>http://yoursite.com/2017/12/30/2017/</id>
    <published>2017-12-30T06:00:56.000Z</published>
    <updated>2020-10-27T04:37:09.699Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/1Hj2iOHToO9uvBNDf36*cLG08F9djRTsvw*pcOXyXM4!/r/dAgBAAAAAAAA" alt="logo"></p><p>回顾17，迎接18年</p><a id="more"></a><blockquote><h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a><strong>工作</strong></h4></blockquote><p>17年有点类似高产，从16年底到17年底一共完成三款应用的上架，伴随着的是都习惯性的加班，个人的总结少了很多，很多都是业务代码的构写。主要是也是公司的“战略”比较多。</p><p>今年是独立开发的开始，项目中的所有都是自己拿主意。有了更多的自由度，也有了更多的尝试。</p><p>从湖南到广州，工作环境的变化，个人效率也高了不少。</p><p>因为现在招聘好一点基本上会看看你的GitHub，个人博客。不像前几年会拉点控件都可以找到一份不错的工作。世界在进步，只有在浪潮退去之后，才知道谁是裸泳，谁在摸鱼。最近开通了个人博客，也准备把躺在印象笔记里面的东西搬出来，以后也陆续更新一些个人的文章，GitHub里面也准备时常更新一些代码，发现之前空白都是比较多。尴尬。。。</p><p><strong>iOS</strong></p><p>目前一个项目是采用swift，Objective-C混编，明年3月份有一个新的项目准备全面采用swift，以后主力采用swift。</p><p><strong>尝试</strong></p><p>小程序也是写了一个Demo就没有下文了，原因也是项目紧，连续几个月的995。。</p><p>机器学习，报了优达学院的入门课程，目前还差P3，P4没有完成。感觉有点打水漂了。</p><p>因为机器学习需要Python，所以陆陆续续学了一段时间，但是由于项目紧又停了一段时间了。</p><blockquote><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a><strong>生活</strong></h4></blockquote><p>结束了晚上回家没有人开灯的情况，虽然两个人都加班比较多。。</p><p>生活没那么贫乏了</p><p>更加有规律，除了晚睡习惯</p><p>除了辣椒，其他东西也有好吃的</p><p>身边的长辈都老了，到了该享乐的年纪，却没有享乐的条件</p><p>物质条件更加好了，却越来越忙</p><blockquote><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h4></blockquote><p>工作方面，需要更多的总结，时常更新内容，向高级开发进军。</p><p>生活方面，保重身体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://r.photo.store.qq.com/psb?/V12RuddS4X20zt/1Hj2iOHToO9uvBNDf36*cLG08F9djRTsvw*pcOXyXM4!/r/dAgBAAAAAAAA&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt;回顾17，迎接18年&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Synchronization</title>
    <link href="http://yoursite.com/2017/12/27/synchronization/"/>
    <id>http://yoursite.com/2017/12/27/synchronization/</id>
    <published>2017-12-27T02:09:34.000Z</published>
    <updated>2020-10-27T05:48:43.580Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序中多线程的存在，带来了有关多个执行线程安全访问资源的潜在问题。两个线程修改同一资源可能会以非预期的方式相互干扰。例如，一个线程可能会覆盖另一个线程的修改，或者使应用程序进入一个未知的、潜在的无效状态。如果你很幸运，被破坏的资源可能会导致明显的性能问题或崩溃，而这些问题相对容易跟踪和修复。然而，如果你不幸运，损坏可能会导致微妙的错误，直到很久以后才会表现出来，或者这些错误可能需要对你的底层编码假设进行重大的整改。</p><p>当涉及到线程安全时，一个好的设计是你最好的保护。避免共享资源，尽量减少你的线程之间的交互，使得这些线程相互干扰的可能性降低。然而，完全无干扰的设计并不总是可能的。在你的线程必须交互的情况下，你需要使用同步工具来确保当它们交互时，能够安全地进行。</p><a id="more"></a><p>OSX和iOS提供了许多同步工具供你使用，从提供互斥访问的工具到在你的应用程序中正确排序事件的工具不一而足。下面的章节描述了这些工具，以及您如何在代码中使用它们来影响对程序资源的安全访问。</p><h2 id="Synchronization-Tools"><a href="#Synchronization-Tools" class="headerlink" title="Synchronization Tools"></a><strong>Synchronization Tools</strong></h2><p>为了防止不同的线程意外地改变数据，你可以将你的应用程序设计成不存在同步问题，或者你可以使用同步工具。虽然完全避免同步问题是可取的，但并不总是可能的。下面的章节描述了可供您使用的同步工具的基本类别。</p><h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><p>原子操作是一种简单的同步形式，工作在简单的数据类型上。原子操作的优点是不会阻塞竞争的线程。对于简单的操作，例如增量一个计数器变量，这可以带来比带锁好得多的性能。</p><p>OSX和iOS包含了许多操作，以对32位和64位的值进行基本的数学和逻辑运算。在这些操作中，有比较和交换、测试和设置以及测试和清除操作的原子版本。关于支持的原子操作的列表，请参见/usr/include/libkern/OSAtomic.h头文件，或者参见atomicman页面。</p><h3 id="Memory-Barriers-and-Volatile-Variables"><a href="#Memory-Barriers-and-Volatile-Variables" class="headerlink" title="Memory Barriers and Volatile Variables"></a>Memory Barriers and Volatile Variables</h3><p>为了实现最佳性能，编译器经常会对汇编级指令进行重新排序，以使处理器的指令流水线尽可能满。作为这种优化的一部分，编译器可能会对访问主内存的指令进行重新排序，如果它认为这样做不会产生错误的数据。不幸的是，编译器并不总是能够检测到所有与内存相关的操作。如果看似独立的变量实际上相互影响，编译器优化可能会以错误的顺序更新这些变量，产生潜在的错误结果。</p><p>内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序发生。内存屏障的作用就像栅栏一样，迫使处理器在完成定位在屏障前面的任何加载和存储操作之后，才允许执行定位在屏障之后的加载和存储操作。内存屏障通常用于确保一个线程（但对另一个线程可见）的内存操作总是按照预期的顺序进行。在这种情况下，缺乏内存屏障可能会让其他线程看到看似不可能的结果。(对于一个例子，请参见维基百科中关于内存屏障的条目。)要采用内存屏障，你只需在代码中的适当位置调用OSMemoryBarrier函数即可。</p><p>易失性变量对单个变量应用另一种类型的内存约束。编译器经常通过将变量的值加载到寄存器中来优化代码。对于局部变量，这通常不是问题。然而，如果变量在另一个线程中可见，这样的优化可能会使另一个线程无法注意到对它的任何更改。将volatile关键字应用于一个变量，会迫使编译器在每次使用该变量时从内存中加载它。如果一个变量的值可能随时被外部源改变，而编译器可能无法检测到，你可以将其声明为易失性变量。</p><p>因为内存屏障和易失性变量都会减少编译器可以执行的优化次数，所以应该尽量少用，只在需要的地方使用，以确保正确性。有关使用内存屏障的信息，请参见OSMemoryBarrier手册页。</p><h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>锁是最常用的同步工具之一。你可以使用锁来保护你的代码的关键部分，也就是一次只允许一个线程访问的代码段。例如，一个关键部分可能会操作一个特定的数据结构或使用一些资源，一次最多支持一个客户端。通过在这个部分周围放置一个锁，你可以排除其他线程进行可能影响代码正确性的修改。</p><p>表4-1列出了一些程序员常用的锁。OSX和iOS为这些锁类型中的大多数提供了实现，但不是所有的锁类型。对于不支持的锁类型，描述栏解释了这些锁没有直接在平台上实现的原因。查锁具有潜在的不安全性，系统不对其提供明确的支持，不鼓励使用双重检查锁。</p><p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcZb5uUS4h8juFgPNmXlqNMZO6A3XJpDTRUtDIAVkG8qHQiJx3nYohftoR3sC8st7AabFi*v.vCZfIcZTAhnswKc!/r" alt="logo"></p><p>注意：大多数类型的锁还包含一个内存屏障，以确保任何前面的加载和存储指令在进入关键部分之前完成。</p><p>有关如何使用锁的信息，请参阅使用锁。</p><h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>条件是另一种类型的信号体，它允许线程在某个条件为真时相互发出信号。条件通常用于指示资源的可用性，或者确保任务按照特定的顺序执行。当一个线程测试一个条件时，除非该条件已经为真，否则它就会被阻塞。在其他线程明确改变并发出信号之前，它一直处于阻塞状态。条件和mutex锁的区别在于，可以允许多个线程同时访问条件。条件更像是一个守门人，根据一些指定的标准允许不同的线程通过门。</p><p>使用条件的一种方式是管理一个待处理事件池。事件队列将使用一个条件变量，当队列中有事件时，向等待的线程发出信号。如果有一个事件到达，队列会适当地发出条件信号。如果一个线程已经在等待，它就会被唤醒，然后从队列中提取事件并进行处理。如果有两个事件同时进入队列，队列会发出两次信号来唤醒两个线程。</p><p>系统提供了几种不同技术的条件支持。但是，条件的正确实现需要仔细的编码，所以在自己的代码中使用条件之前，应该先看看《使用条件》中的例子。</p><h3 id="Perform-Selector-Routines"><a href="#Perform-Selector-Routines" class="headerlink" title="Perform Selector Routines"></a>Perform Selector Routines</h3><p>Cocoa应用程序有一种方便的方法，可以将消息以同步的方式传递给单个线程。NSObject类声明了用于在应用程序的一个活动线程上执行选择器的方法。这些方法让你的线程在保证目标线程同步执行消息的情况下，异步地传递消息。例如，你可以使用执行选择器消息将分布式计算的结果传递给你的应用程序的主线程或指定的协调者线程。每个执行选择器的请求都会在目标线程的运行循环上排队，然后按照收到请求的顺序依次处理。</p><p>有关执行选择器例程的摘要和有关如何使用它们的更多信息，请参阅Cocoa执行选择器源。</p><h2 id="Synchronization-Costs-and-Performance"><a href="#Synchronization-Costs-and-Performance" class="headerlink" title="Synchronization Costs and Performance"></a><strong>Synchronization Costs and Performance</strong></h2><p>同步有助于确保代码的正确性，但这样做是以牺牲性能为代价的。使用同步工具会引入延迟，即使在无争议的情况下也是如此。锁和原子操作通常涉及使用内存屏障和内核级同步来确保代码得到适当保护。而如果存在对锁的争夺，你的线程可能会阻塞并经历更大的延迟。</p><p>表4-2列出了一些在无竞争情况下与mutexes和原子操作相关的大致成本。这些测量结果代表了几千个样本的平均时间。不过和线程创建时间一样，mutex的获取时间（即使在无争议的情况下）也会因处理器负载、计算机速度以及可用的系统和程序内存量而有很大差异。</p><p>表4-2互换和原子操作耗费</p><p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth*pXbK3EaXZxBB3Qm1o22JWm6Xex6sY3Nd4JDRJQaWefLFalYVCDEzV5qvIBLRVIHI!/r" alt="logo"></p><p>在设计并发任务时，正确性永远是最重要的因素，但你也应该考虑性能因素。在多线程下正确执行的代码，却比在单线程上运行的相同代码慢，很难说是一种改进。</p><p>如果你正在改造一个现有的单线程应用程序，你应该始终对关键任务的性能进行一组基线测量。在添加额外的线程后，你应该对这些相同的任务进行新的测量，并将多线程情况和单线程情况的性能进行比较。如果在调整代码后，线程并没有提高性能，你可能要重新考虑你的具体实现或完全使用线程。</p><p>关于性能和收集指标的工具的信息，请参见性能概述。关于锁和原子操作的成本的具体信息，请参见线程消耗。</p><h2 id="Thread-Safety-and-Signals"><a href="#Thread-Safety-and-Signals" class="headerlink" title="Thread Safety and Signals"></a><strong>Thread Safety and Signals</strong></h2><p>谈到线程应用，没有什么比处理信号的问题更让人恐惧或困惑。信号是一种低级的BSD机制，可以用来向进程传递信息或以某种方式操纵它。一些程序使用信号来检测某些事件，例如子进程的死亡。系统使用信号来终止失控的进程和传达其他类型的信息。</p><p>信号的问题不在于它们的作用，而是当你的应用程序有多个线程时它们的行为。在单线程应用程序中，所有信号处理程序都运行在主线程上。在多线程应用程序中，不与特定硬件错误（如非法指令）相关联的信号会传递给当时恰好运行的任何一个线程。如果多个线程同时运行，则信号会传递给系统恰好选择的那个线程。换句话说，信号可以传递给应用程序的任何线程。</p><p>在应用程序中实现信号处理程序的第一条规则是避免假设哪个线程在处理信号。如果一个特定的线程想要处理一个给定的信号，你需要想办法在信号到达时通知这个线程。你不能仅仅假设从该线程安装信号处理程序会导致信号被传递到同一个线程。</p><p>关于信号和安装信号处理程序的更多信息，请参见信号和sigaction手册页。</p><h2 id="Tips-for-Thread-Safe-Designs"><a href="#Tips-for-Thread-Safe-Designs" class="headerlink" title="Tips for Thread-Safe Designs"></a><strong>Tips for Thread-Safe Designs</strong></h2><p>同步工具是使你的代码线程安全的有用方法，但它们不是万能的。过度使用锁和其他类型的同步基元，与非线程性能相比，实际上会降低应用程序的线程性能。在安全和性能之间找到正确的平衡点是一门需要经验的艺术。以下章节提供了一些提示，帮助您为应用程序选择适当的同步级别。</p><h3 id="Avoid-Synchronization-Altogether"><a href="#Avoid-Synchronization-Altogether" class="headerlink" title="Avoid Synchronization Altogether"></a>Avoid Synchronization Altogether</h3><p>对于你所从事的任何新项目，甚至对于现有的项目，设计你的代码和数据结构以避免对同步的需求是最好的解决方案。虽然锁和其他同步工具很有用，但它们确实会影响任何应用程序的性能。而且如果整体设计导致特定资源之间的高度争用，你的线程可能会等待更长时间。</p><p>实现并发的最好方法是减少你的并发任务之间的相互作用和相互依赖。如果每个任务都在自己的私有数据集上运行，它就不需要使用锁来保护这些数据。即使在两个任务确实共享一个公共数据集的情况下，你也可以研究如何对该数据集进行分区，或者为每个任务提供自己的副本。当然，复制数据集也是有成本的，所以在做出决定之前，你必须权衡这些成本和同步的成本。</p><h3 id="Understand-the-Limits-of-Synchronization"><a href="#Understand-the-Limits-of-Synchronization" class="headerlink" title="Understand the Limits of Synchronization"></a>Understand the Limits of Synchronization</h3><p>同步工具只有在应用程序中的所有线程一致使用它们时才有效。如果您创建了一个mutex来限制对特定资源的访问，那么您的所有线程在尝试操作该资源之前必须获得相同的mutex。如果不这样做，就会使mutex提供的保护失效，并且是程序员的错误。</p><h3 id="Be-Aware-of-Threats-to-Code-Correctness"><a href="#Be-Aware-of-Threats-to-Code-Correctness" class="headerlink" title="Be Aware of Threats to Code Correctness"></a>Be Aware of Threats to Code Correctness</h3><p>当使用锁和内存屏障时，你应该总是仔细考虑它们在你的代码中的位置。即使是看起来放置得很好的锁，实际上也会让你陷入一种错误的安全感。下面的一系列例子试图通过指出看似无害的代码中的缺陷来说明这个问题。基本前提是，你有一个包含一组不可变对象的可变数组。假设你想调用数组中第一个对象的方法。你可以使用下面的代码来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br></pre></td></tr></table></figure><p>因为数组是可变的，所以数组周围的锁可以防止其他线程修改数组，直到你得到想要的对象。而且因为你所检索的对象本身是不可变的，所以在调用doSomething方法的周围不需要锁。</p><p>不过，前面的例子有一个问题。如果你释放了锁，而另一个线程进来，在你有机会执行doSomething方法之前就从数组中删除了所有对象，会发生什么？在一个没有垃圾回收的应用程序中，你的代码所持有的对象可能会被释放，留下一个指向无效内存地址的Object。为了解决这个问题，你可能会决定简单地重新安排你现有的代码，并在调用doSomething之后释放锁，如这里所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[anObject doSomething];</span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure><p>通过将doSomething调用移到锁里面，你的代码可以保证当方法被调用时，对象仍然有效。不幸的是，如果doSomething方法执行的时间很长，这可能会导致你的代码长时间保持锁，从而产生性能瓶颈。</p><p>代码的问题并不是关键区域定义得不好，而是没有理解实际问题。真正的问题是内存管理问题，只有在其他线程存在时才会触发。因为它可以被其他线程释放，所以更好的解决方案是在释放锁之前保留一个Object。这个解决方案解决了对象被释放的实际问题，而且不会引入潜在的性能惩罚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSLock* arrayLock = GetArrayLock();</span><br><span class="line">NSMutableArray* myArray = GetSharedArray();</span><br><span class="line">id anObject;</span><br><span class="line"> </span><br><span class="line">[arrayLock lock];</span><br><span class="line">anObject = [myArray objectAtIndex:0];</span><br><span class="line">[anObject retain];</span><br><span class="line">[arrayLock unlock];</span><br><span class="line"> </span><br><span class="line">[anObject doSomething];</span><br><span class="line">[anObject release];</span><br></pre></td></tr></table></figure><p>虽然前面的例子很简单，但确实说明了一个很重要的问题。当涉及到正确性时，你必须考虑到明显的问题之外。内存管理和你的设计的其他方面也可能会因为多线程的存在而受到影响，所以你必须事先考虑到这些问题。此外，你应该始终假设编译器在安全问题上会做最坏的打算。这种意识和警惕性应该可以帮助你避免潜在的问题，并确保你的代码表现正确。</p><p>关于如何使你的程序线程安全的其他例子，请看线程安全总结。</p><h3 id="Watch-Out-for-Deadlocks-and-Livelocks"><a href="#Watch-Out-for-Deadlocks-and-Livelocks" class="headerlink" title="Watch Out for Deadlocks and Livelocks"></a>Watch Out for Deadlocks and Livelocks</h3><p>任何时候，当一个线程试图同时获取一个以上的锁时，都有可能发生死锁。当两个不同的线程持有另一个线程需要的锁，然后试图获取另一个线程持有的锁时，就会发生死锁。其结果是，每个线程都永久阻塞，因为它永远无法获得另一个锁。</p><p>livelock类似于死锁，发生在两个线程争夺同一组资源的时候。在livelock情况下，一个线程放弃它的第一个锁，试图获得第二个锁。一旦它获得了第二个锁，它就会返回并试图再次获得第一个锁。它之所以锁死，是因为它把所有的时间都花在释放一个锁和试图获取另一个锁上，而不是做任何真正的工作。</p><p>避免死锁和活锁情况的最好方法是一次只取一把锁。如果你必须一次获取一个以上的锁，你应该确保其他线程不会尝试做类似的事情。</p><h3 id="Use-Volatile-Variables-Correctly"><a href="#Use-Volatile-Variables-Correctly" class="headerlink" title="Use Volatile Variables Correctly"></a>Use Volatile Variables Correctly</h3><p>如果你已经在使用mutex来保护某段代码，不要自动认为你需要使用volatile关键字来保护该段代码中的重要变量。一个mutex包括一个内存屏障，以确保加载和存储操作的正确顺序。将volatile关键字添加到关键部分内的变量中，会强制每次访问时从内存中加载该值。在特定情况下，这两种同步技术的结合可能是必要的，但也会导致显著的性能惩罚。如果仅用mutex就足以保护变量，请省略volatile关键字。</p><p>同样重要的是，不要为了避免使用mutexes而使用volatile变量。一般来说，mutexes和其他同步机制比volatile变量更能保护你的数据结构的完整性。volatile关键字只确保变量从内存中加载，而不是存储在寄存器中。它不能确保变量被你的代码正确访问。</p><h3 id="Using-Atomic-Operations"><a href="#Using-Atomic-Operations" class="headerlink" title="Using Atomic Operations"></a>Using Atomic Operations</h3><p>非阻塞同步是一种执行某些类型操作并避免锁的费用的方法。虽然锁是同步两个线程的有效方式，但获取锁是一种相对昂贵的操作，即使是在无争议的情况下。相比之下，许多原子操作只需要很少的时间就能完成，而且可以和锁一样有效。</p><p>原子运算让你可以对32位或64位的值进行简单的数学和逻辑运算。这些操作依靠特殊的硬件指令（以及一个可选的内存屏障）来确保给定的操作在受影响的内存被再次访问之前完成。在多线程的情况下，应该始终使用包含内存屏障的原子操作，以确保内存在线程之间正确同步。</p><p>表4-3列出了可用的原子数学和逻辑运算以及相应的函数名称。这些函数都是在/usr/include/libkern/OSAtomic.h头文件中声明的，在那里也可以找到完整的语法。这些函数的64位版本只在64位进程中可用。</p><p>表4-3原子数学和逻辑运算。<br>    <img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth.oOyCkLycLr3mLW2ase4ETPt9xDKYYNKFPXpehZaV3qS1BZPD*20CcbXjXNUFa614!/r" alt=""><br>    <img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcbtbMBEdEi41c8x47Qnpth*pZ1VUDRh5gJ46jbtVfVoJ7jtwhu9SOEADPWpanalssBwqmmFIua4Pts7IXpCg2sY!/r" alt=""><br>    大多数原子函数的行为应该是相对简单的，也是你所期望的。然而，清单4-1显示了原子测试和设置以及比较和交换操作的行为，这些操作要复杂一些。对OSAtomicTestAndSet函数的前三次调用展示了在整数值上使用的位操作公式及其结果如何与你所期望的不同。最后两次调用展示了OSAtomicCompareAndSwap32函数的行为。在所有情况下，这些函数都是在无争议的情况下被调用的，当时没有其他线程在操作这些值。<br>    清单4-1执行原子操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32_t  theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(0, &amp;theValue);</span><br><span class="line">// theValue is now 128.</span><br><span class="line"> </span><br><span class="line">theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(7, &amp;theValue);</span><br><span class="line">// theValue is now 1.</span><br><span class="line"> </span><br><span class="line">theValue = 0;</span><br><span class="line">OSAtomicTestAndSet(15, &amp;theValue)</span><br><span class="line">// theValue is now 256.</span><br><span class="line"> </span><br><span class="line">OSAtomicCompareAndSwap32(256, 512, &amp;theValue);</span><br><span class="line">// theValue is now 512.</span><br><span class="line"> </span><br><span class="line">OSAtomicCompareAndSwap32(256, 1024, &amp;theValue);</span><br><span class="line">// theValue is still 512.</span><br></pre></td></tr></table></figure><p>关于原子操作的信息，请参见atomicman页面和/usr/include/libkern/OSAtomic.h头文件。</p><h2 id="Using-Locks"><a href="#Using-Locks" class="headerlink" title="Using Locks"></a><strong>Using Locks</strong></h2><p>锁是线程编程的基本同步工具。锁使你能够轻松地保护大段代码，从而保证代码的正确性。OSX和iOS为所有应用类型提供了基本的mutex锁，Foundation框架为特殊情况定义了一些额外的mutex锁变体。下面的章节将向您展示如何使用其中的几种锁类型。</p><h3 id="Using-a-POSIX-Mutex-Lock"><a href="#Using-a-POSIX-Mutex-Lock" class="headerlink" title="Using a POSIX Mutex Lock"></a>Using a POSIX Mutex Lock</h3><p>POSIX的mutex锁在任何应用程序中都非常容易使用。要创建mutex锁，你需要声明并初始化一个pthread_mutex_t结构。要锁定和解锁mutex锁，需要使用pthread_mutex_lock和pthread_mutex_unlock函数。清单4-2显示了初始化和使用POSIX线程mutex锁所需的基本代码。当你使用完锁后，只需调用pthread_mutex_destroy来释放锁的数据结构。</p><p>清单4-2使用mutex锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mutex;</span><br><span class="line">void MyInitFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyLockingFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    // Do work.</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：前面的代码是一个简化的例子，旨在展示POSIX线程mutex函数的基本用法。你自己的代码应该检查这些函数返回的错误代码，并适当地处理它们。</p><h3 id="Using-the-NSLock-Class"><a href="#Using-the-NSLock-Class" class="headerlink" title="Using the NSLock Class"></a>Using the NSLock Class</h3><p>NSLock对象为Cocoa应用程序实现了一个基本的mutex。所有锁（包括NSLock）的接口实际上是由NSLocking协议定义的，它定义了锁和解锁方法。您使用这些方法来获取和释放锁，就像您使用任何mutex一样。</p><p>除了标准的锁定行为，NSLock类还增加了tryLock和lockBeforeDate:方法。tryLock方法试图获取锁，但如果锁不可用，则不会阻塞；相反，该方法只返回NO。lockBeforeDate:方法试图获取锁，但如果在指定的时间限制内没有获取锁，则会解锁线程（并返回NO）。</p><p>下面的例子显示了如何使用NSLock对象来协调一个可视化显示器的更新，该显示器的数据正由多个线程计算。如果线程不能立即获取锁，它只是继续计算，直到它能获取锁并更新显示屏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL moreToDo = YES;</span><br><span class="line">NSLock *theLock = [[NSLock alloc] init];</span><br><span class="line">...</span><br><span class="line">while (moreToDo) &#123;</span><br><span class="line">    /* Do another increment of calculation */</span><br><span class="line">    /* until there’s no more to do. */</span><br><span class="line">    if ([theLock tryLock]) &#123;</span><br><span class="line">        /* Update display used by all threads. */</span><br><span class="line">        [theLock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-the-synchronized-Directive"><a href="#Using-the-synchronized-Directive" class="headerlink" title="Using the @synchronized Directive"></a>Using the @synchronized Directive</h3><p>@synchronized指令是在Objective-C代码中创建mutex锁的便捷方式。@synchronized指令的作用和其他mutex锁一样–它可以防止不同的线程在同一时间获取同一个锁。然而，在这种情况下，您不必直接创建mutex或锁对象。取而代之的是，您只需使用任何Objective-C对象作为锁标记，如下例所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj</span><br><span class="line">&#123;</span><br><span class="line">    @synchronized(anObj)</span><br><span class="line">    &#123;</span><br><span class="line">        // Everything between the braces is protected by the @synchronized directive.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给@synchronized指令的对象是一个唯一的标识符，用来区分保护块。如果在两个不同的线程中执行前面的方法，在每个线程上为anObj参数传递一个不同的对象，每个线程都会取得它的锁并继续处理，而不会被另一个线程阻塞。然而，如果在两种情况下传递相同的对象，其中一个线程将首先取得锁，另一个线程将阻塞，直到第一个线程完成关键部分。<br>    作为一种预防措施，@synchronizedblock隐含地在保护代码中添加了一个异常处理程序。这个处理程序会在抛出异常的情况下自动释放mutex。这意味着为了使用@synchronized指令，你必须在你的代码中启用Objective-C异常处理。如果你不想要隐式异常处理程序造成的额外开销，你应该考虑使用锁类。<br>    有关@synchronized指令的更多信息，请参阅Objective-C编程语言。</p><h3 id="Using-Other-Cocoa-Locks"><a href="#Using-Other-Cocoa-Locks" class="headerlink" title="Using Other Cocoa Locks"></a>Using Other Cocoa Locks</h3><p>下面的章节描述了使用其他几种类型的Cocoa锁的过程。</p><h3 id="Using-an-NSRecursiveLock-Object"><a href="#Using-an-NSRecursiveLock-Object" class="headerlink" title="Using an NSRecursiveLock Object"></a>Using an NSRecursiveLock Object</h3><p>NSRecursiveLock类定义了一个可以被同一线程多次获取而不会导致线程死锁的锁。递归锁会跟踪它被成功获取的次数。每次成功获取锁的时候，必须有一个相应的调用来平衡解锁。只有当所有的锁和解锁调用都被平衡时，锁才会被真正释放，以便其他线程可以获取它。</p><p>顾名思义，这种类型的锁通常用于递归函数内部，以防止递归阻塞线程。在非递归的情况下，你同样可以用它来调用那些语义上要求它们也获取锁的函数。下面是一个简单的递归函数的例子，它通过递归获取锁。如果你没有在这段代码中使用NSRecursiveLock对象，当函数再次被调用时，线程就会死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];</span><br><span class="line"> </span><br><span class="line">void MyRecursiveFunction(int value)</span><br><span class="line">&#123;</span><br><span class="line">    [theLock lock];</span><br><span class="line">    if (value != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        --value;</span><br><span class="line">        MyRecursiveFunction(value);</span><br><span class="line">    &#125;</span><br><span class="line">    [theLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MyRecursiveFunction(5);</span><br></pre></td></tr></table></figure><p>注意：由于递归锁在所有锁调用与解锁调用平衡之前不会被释放，因此您应该仔细权衡使用性能锁的决定与潜在的性能影响。长时间保持任何锁都会导致其他线程阻塞，直到递归完成。如果你能重写你的代码以消除递归或消除使用递归锁的需要，你可能会获得更好的性能。</p><h3 id="Using-an-NSConditionLock-Object"><a href="#Using-an-NSConditionLock-Object" class="headerlink" title="Using an NSConditionLock Object"></a>Using an NSConditionLock Object</h3><p>NSConditionLock对象定义了一个mutex锁，它可以用特定的值进行锁定和解锁。您不应该将这种类型的锁与条件混淆起来（参见条件）。其行为与条件有些类似，但实现方式非常不同。<br>    通常情况下，当线程需要按照特定的顺序执行任务时，例如当一个线程生产数据，另一个线程消费数据时，您会使用NSConditionLock对象。当生产者在执行时，消费者使用一个特定于你的程序的条件来获取锁。(条件本身只是一个您定义的整数值。)当生产者完成时，它解锁并将锁条件设置为适当的整数值，以唤醒消费者线程，然后继续处理数据。<br>    NSConditionLock对象响应的锁定和解锁方法可以任意组合使用。例如，你可以将锁定消息与unlockWithCondition:配对，或者将lockWhenCondition:消息与解锁配对。当然，后一种组合可以解锁锁，但可能不会释放任何等待特定条件值的线程。<br>    下面的例子展示了如何使用条件锁来处理生产者-消费者问题。想象一下，一个应用程序包含一个数据队列。生产者线程向队列添加数据，消费者线程从队列中提取数据。生产者不需要等待特定的条件，但它必须等待锁可用，这样它才能安全地将数据添加到队列中。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">    [condLock lock];</span><br><span class="line">    /* Add data to the queue. */</span><br><span class="line">    [condLock   unlockWithCondition:HAS_DATA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>因为锁的初始条件被设置为NO_DATA，所以生产者线程最初获取锁应该没有问题。它用数据填充队列，并将条件设置为HAS_DATA。在随后的迭代过程中，生产者线程可以在新数据到达时添加新数据，不管队列是空的还是还有一些数据。唯一的一次阻塞是当消费者线程从队列中提取数据的时候。<br>    因为消费线程必须有数据要处理，所以它使用特定的条件在队列上等待。当生产者将数据放在队列上时，消费线程就会被唤醒并获得它的锁。然后，它可以从队列中提取一些数据并更新队列状态。下面的例子显示了消费者线程处理循环的基本结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    while (true)&#123;</span><br><span class="line">    [condLock lockWhenCondition:HAS_DATA];</span><br><span class="line">    /* Remove data from the queue. */</span><br><span class="line">    [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)];</span><br><span class="line">    // Process the data locally.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-an-NSDistributedLock-Object"><a href="#Using-an-NSDistributedLock-Object" class="headerlink" title="Using an NSDistributedLock Object"></a>Using an NSDistributedLock Object</h3><p>NSDistributedLock类可以被多个主机上的多个应用程序用来限制对某些共享资源的访问，比如文件。锁本身实际上是一个mutex锁，它是使用文件系统项（如文件或目录）实现的。为了使NSDistributedLock对象可以使用，该锁必须可以被所有使用它的应用程序写入。这通常意味着把它放在一个文件系统上，所有运行该应用程序的计算机都可以访问。<br>    与其他类型的锁不同，NSDistributedLock不符合NSLocking协议，因此没有锁方法。锁定方法会阻止线程的执行，并要求系统以预定的速度轮询锁。NSDistributedLock没有将这种惩罚强加在你的代码上，而是提供了一个tryLock方法，让你决定是否轮询。<br>    因为它是使用文件系统实现的，一个NSDistributedLock对象不会被释放，除非所有者明确释放它。如果您的应用程序在持有分布式锁时崩溃，其他客户端将无法访问受保护的资源。在这种情况下，你可以使用breakLock方法来打破现有的锁，这样你就可以获得它。不过一般来说，应该避免破坏锁，除非你确定拥有锁的进程死亡，无法释放锁。<br>    和其他类型的锁一样，当你使用完一个NSDistributedLock对象后，你可以通过调用unlock方法来释放它。</p><h2 id="Using-Conditions"><a href="#Using-Conditions" class="headerlink" title="Using Conditions"></a><strong>Using Conditions</strong></h2><p>条件锁是一种特殊类型的锁，你可以用它来同步操作必须进行的顺序。它们与mutex锁有细微的不同。在条件锁上等待的线程会一直被阻塞，直到另一个线程明确地发出信号。<br>    由于实现操作系统的微妙之处，条件锁被允许以虚假的成功返回，即使它们实际上没有被你的代码发出信号。为了避免这些虚假信号引起的问题，你应该总是使用一个谓词与你的条件锁一起使用。谓词是确定线程是否安全进行的更具体的方法。条件只是让你的线程保持睡眠状态，直到信号线程可以设置谓词。<br>    下面的章节将向你展示如何在你的代码中使用条件。</p><h3 id="Using-the-NSCondition-Class"><a href="#Using-the-NSCondition-Class" class="headerlink" title="Using the NSCondition Class"></a>Using the NSCondition Class</h3><p>iNSCondition类提供了与POSIX条件相同的语义，但将所需的锁和条件数据结构封装在一个对象中。其结果是一个对象，您可以像mutex一样锁定，然后像条件一样等待。<br>    清单4-3显示了一个代码片段，演示了等待NSCondition对象的事件序列。cocoaCondition变量包含一个NSCondition对象，而timeToDoWork变量则是一个整数，它在发出条件信号之前从另一个线程中增量。<br>清单4-3使用Cocoa条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[cocoaCondition lock];</span><br><span class="line">while (timeToDoWork &lt;= 0)</span><br><span class="line">    [cocoaCondition wait];</span><br><span class="line"> </span><br><span class="line">timeToDoWork--;</span><br><span class="line"> </span><br><span class="line">// Do real work here.</span><br><span class="line"> </span><br><span class="line">[cocoaCondition unlock];</span><br></pre></td></tr></table></figure><p>清单4-4显示了用来给Cocoa条件发信号和递增谓词变量的代码。在发出信号之前，您应该始终锁定条件。<br>清单4-4SignalingaCocoa条件信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[cocoaCondition lock];</span><br><span class="line">timeToDoWork++;</span><br><span class="line">[cocoaCondition signal];</span><br><span class="line">[cocoaCondition unlock];</span><br></pre></td></tr></table></figure><h3 id="Using-POSIX-Conditions"><a href="#Using-POSIX-Conditions" class="headerlink" title="Using POSIX Conditions"></a>Using POSIX Conditions</h3><p>POSIX线程条件锁需要同时使用条件数据结构和mutex。虽然这两个锁结构是分开的，但在运行时，mutex锁与条件结构紧密相连。等待信号的线程应该始终一起使用相同的mutex锁和条件结构。改变配对会导致错误。<br>    清单4-5显示了条件和谓词的基本初始化和用法。在初始化条件和mutex锁后，等待线程进入一个while循环，使用ready_to_go变量作为其谓词。只有当谓词被设置且条件随后被发出信号时，等待线程才会被唤醒并开始做它的工作。<br>清单4-5使用POSIX条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">Boolean     ready_to_go = true;</span><br><span class="line"> </span><br><span class="line">void MyCondInitFunction()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex);</span><br><span class="line">    pthread_cond_init(&amp;condition, NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void MyWaitOnConditionFunction()</span><br><span class="line">&#123;</span><br><span class="line">    // Lock the mutex.</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"> </span><br><span class="line">    // If the predicate is already set, then the while loop is bypassed;</span><br><span class="line">    // otherwise, the thread sleeps until the predicate is set.</span><br><span class="line">    while(ready_to_go == false)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Do work. (The mutex should stay locked.)</span><br><span class="line"> </span><br><span class="line">    // Reset the predicate and release the mutex.</span><br><span class="line">    ready_to_go = false;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号线程既要负责设置谓词，又要负责向条件锁发送信号。清单4-6显示了实现这种行为的代码。在这个例子中，条件是在mutex内部发出信号的，以防止在等待条件的线程之间发生竞赛条件。<br>清单4-6给条件锁发送信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void SignalThreadUsingCondition()</span><br><span class="line">&#123;</span><br><span class="line">    // At this point, there should be work for the other thread to do.</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    ready_to_go = true;</span><br><span class="line"> </span><br><span class="line">    // Signal the other thread to begin work.</span><br><span class="line">    pthread_cond_signal(&amp;condition);</span><br><span class="line"> </span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：前面的代码是一个简化的例子，旨在展示POSIX线程条件函数的基本用法。你自己的代码应该检查这些函数返回的错误代码，并适当地处理它们。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序中多线程的存在，带来了有关多个执行线程安全访问资源的潜在问题。两个线程修改同一资源可能会以非预期的方式相互干扰。例如，一个线程可能会覆盖另一个线程的修改，或者使应用程序进入一个未知的、潜在的无效状态。如果你很幸运，被破坏的资源可能会导致明显的性能问题或崩溃，而这些问题相对容易跟踪和修复。然而，如果你不幸运，损坏可能会导致微妙的错误，直到很久以后才会表现出来，或者这些错误可能需要对你的底层编码假设进行重大的整改。&lt;/p&gt;
&lt;p&gt;当涉及到线程安全时，一个好的设计是你最好的保护。避免共享资源，尽量减少你的线程之间的交互，使得这些线程相互干扰的可能性降低。然而，完全无干扰的设计并不总是可能的。在你的线程必须交互的情况下，你需要使用同步工具来确保当它们交互时，能够安全地进行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
