{"pages":[{"title":"about","text":"种一棵树最好的时间是十年前 其次是现在 个人简介iOSPythonFlutter小程序 联系方式Gmail : luoshuaihome@gmail.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"iOS多任务-GCD篇","text":"iOS多任务首篇iOS多任务首篇iOS多任务首篇iOS多任务首篇 本文主要是讲解iOS开发中多线程的问题","link":"/test/iOS多任务-GCD篇.html"},{"title":"Markdown","text":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 支持以 PDF 格式导出文稿 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 新增 Todo 列表功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass:passif __name__ == '__main__':# A commentprint 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定需求分析 :a1, 2016-06-22, 3d可行性报告 :after a1, 5d概念验证 : 5dsection 项目实施概要设计 :2016-07-05 , 5d详细设计 :2016-07-08, 10d编码 :2016-07-15, 10d测试 :2016-07-22, 5dsection 发布验收发布: 2d验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","link":"/test/Markdown.html"},{"title":"Core Graphics","text":"简介：大部分我们的UI控件以及视图都是基于UIKit创建，UIKit框架已经集合了绝大部分的UI展示，但是在一些特殊的需求下，仅仅使用UIKit已经无法满足我们的需求了。本篇将简单介绍Core Graphics。 基本概念当我们使用Core Graphics的时候，其中最主要是使用Quartz 2D的API，可以让我们在内存中直接绘制图像。在“绘制”过程中，我们可以形象比喻成一张画布。如果我们将整张画布涂成红色，再将整张画布涂成蓝色，如果蓝色透明度为1，那么现在这张画布为蓝色。如果蓝色透明度为0.5，那么现在这张画布为紫色。如果完全透明，就是红色。在我们使用Quartz 2D的过程也是类似相同的原理。 绘图方式通常在使用Quartz绘制图形时，会在drawRect:方法中编写代码。当每次视图需要自身重新绘制时都会调用drawRect: 绘图环境（画布）前面我们提到在使用Quartz的时候，有类似于绘图的原理。所以在我们开始用Quartz需要获取系统默认的“画布”，也可以自己创建一个自己的“画布”。当我们需要实现创建一个不想立即显示的内容，我们就可以自己创建一个“画布”。系统默认的环境（画布），如下： 1CGContextRef context = UIGraphicsGetCurrentContext(); // C语言 我们简单的绘制一条红色的实线 12345678910- (void)drawRect:(CGRect)rect {// Drawing code CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 获取当前默认环境（画布） CGContextMoveToPoint(contextRef, 10.0, 80.0); // “笔的起始点” CGContextAddLineToPoint(contextRef, 80.0, 80.0); // “笔的结束点” CGContextSetLineWidth(contextRef, 5.0); // “笔的宽度” CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor); // “笔的填充模式，以及颜色” CGContextStrokePath(contextRef); CGContextClosePath(contextRef);// “绘制结束”} 在我们绘制的过程中，CGContextStrokePath()未调用的时候，我们前面所做的操作是“看不见的”。当我们调用CGContextStrokePath()的时候相当于告知Quartz来绘制之前“配置”的图。使用Quartz 2D一般由一下几步构成： 获取图形上下文 创建并设置路径 将路径添加到上下文 设置上下文相关状态 绘制路径 释放路径 一般图形的绘制当我们需要绘制一般的图形我们可以借助Quartz提供的函数进行绘制，比如虚线，矩形，椭圆，曲线等，我们先绘制一些简单的图案： 123456789101112131415161718192021222324252627282930313233343536373839404142CGContextRef contextRef = UIGraphicsGetCurrentContext();//直线CGContextMoveToPoint(contextRef, 20, 80); // “笔的起始点”CGContextAddLineToPoint(contextRef, 100, 80); // “笔的结束点”CGContextSetLineWidth(contextRef, 5); // “笔的宽度”CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor); // “笔的填充模式，以及颜色”CGContextStrokePath(contextRef); // “绘制结束”[@&quot;直线&quot; drawInRect:CGRectMake(20, 80 + 20, 80, 20) withAttributes:self.attribute];//折线CGContextSetLineCap(contextRef, kCGLineCapSquare);//线条样式CGContextSetLineWidth(contextRef, 5);//线条粗细宽度CGContextSetRGBStrokeColor(contextRef, 0, 1, 0, 1);//设置颜色CGContextBeginPath(contextRef);// “笔的起始点”CGContextMoveToPoint(contextRef, 20, 170);CGContextAddLineToPoint(contextRef, 30, 190);//下一个坐标点CGContextAddLineToPoint(contextRef, 40, 160);//下一个坐标点CGContextAddLineToPoint(contextRef, 60, 210);//下一个坐标点CGContextAddLineToPoint(contextRef, 100, 210);//下一个坐标点CGContextStrokePath(contextRef);//连接上面定义的坐标点[@&quot;折线&quot; drawInRect:CGRectMake(20, 210 + 20, 80, 20) withAttributes:self.attribute];CGContextAddRect(contextRef, CGRectMake(20, 280, 60, 60));CGContextSetStrokeColorWithColor(contextRef, [UIColor brownColor].CGColor);CGContextStrokePath(contextRef);[@&quot;矩形&quot; drawInRect:CGRectMake(20, 340 + 20, 60, 20) withAttributes:self.attribute];CGContextAddEllipseInRect(contextRef, CGRectMake(200, 60, 100, 100));CGContextSetFillColorWithColor(contextRef, [UIColor blueColor].CGColor);CGContextFillPath(contextRef);[@&quot;圆&quot; drawInRect:CGRectMake(200, 60 + 100 + 20, 100, 20) withAttributes:self.attribute];CGContextAddEllipseInRect(contextRef, CGRectMake(200, 250, 100, 80));CGContextSetFillColorWithColor(contextRef, [UIColor blueColor].CGColor);CGContextFillPath(contextRef);[@&quot;椭圆&quot; drawInRect:CGRectMake(200, 250 + 80 + 20, 100, 20) withAttributes:self.attribute]; 以上绘制比较容易理解，不做过多介绍，接下来绘制虚线： 1234567891011121314151617181920212223//虚线CGContextSetStrokeColorWithColor(contextRef, [UIColor blackColor].CGColor);CGContextSetLineCap(contextRef, kCGLineCapButt);CGContextSetLineWidth(contextRef, 5);CGContextMoveToPoint(contextRef, 0, 450);CGContextAddLineToPoint(contextRef, kScreenWidth, 450);CGFloat array0[] = {10,20,30,40};//设置虚线排列方式:下面的array0中的数字表示先绘制10个点空20个点再绘制30个点再空40个点，如此反复循环CGContextSetLineDash(contextRef, 0, array0, 4);//最后一个参数“4”代表排列的个数，取前面四个值(10,20,30,40)反复循环CGContextDrawPath(contextRef, kCGPathStroke);CGContextMoveToPoint(contextRef, 0, 470);CGContextAddLineToPoint(contextRef, kScreenWidth, 470);CGFloat array1[] = {10,20,30,40};CGContextSetLineDash(contextRef, 0, array1, 1);//最后一个参数“1”代表排列的个数，取前面1个值(10)反复循环CGContextDrawPath(contextRef, kCGPathStroke);CGContextMoveToPoint(contextRef, 0, 490);CGContextAddLineToPoint(contextRef, kScreenWidth, 490);CGFloat array2[] = {10,20,30,40};CGContextSetLineDash(contextRef, 10, array2, 1);//第二个参数表示第一次“循环”时跳过十个点CGContextDrawPath(contextRef, kCGPathStroke);[@&quot;虚线&quot; drawInRect:CGRectMake(0, 490 + 20, kScreenWidth, 20) withAttributes:self.attribute]; 虚线的绘制主要是理解CGContextSetLineDash中的几个参数，首先我们要明白，虚线是由“绘制”和“留空”组合起来的线。那么在绘制过程中，主要是标记什么时候“绘制”，什么时候“留空”。在array0、array1、array2中的数字就是用来标记的。当CGContextSetLineDash最后一个参数为几就会取前几个数字进行标记。比如当为1时就会取array0的10作为标记参数，在CGContextSetLineDash第二个参数为0时，整个标记规则为先“绘制”10点，再“留空”10点，再“绘制”10点，再“留空”10点，如此往复，直到绘制结束；在CGContextSetLineDash第二个参数为10(或者5)时，在第一轮绘制的时候会先“跳过”10(或者5)点的绘制，如果是5就先“绘制”五个点(10减去5)，如果是10就直接先“绘制”0个点(即直接先留空十个点)，往后的往复则按正常绘制，无需“跳过”，直到绘制结束。当为3时就会去array0的(10,20,30)作为标记参数，后续规则跟之前的是一样的。 弧线的绘制：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//弧线CGContextSetLineDash(contextRef, 0, array2, 0);CGContextSetLineWidth(contextRef, 1);CGContextSetStrokeColorWithColor(contextRef, [UIColor redColor].CGColor);CGContextAddArc(contextRef, 420, 150, 30, 0, M_PI, 1);CGContextStrokePath(contextRef);/* CGContextAddArc(contextRef, 420, 150, 30, 0, M_PI, 1) 圆心：(420, 150) 半径：30 启始角度：0 结束角度：M_PI 旋转方向：1 顺时针 0 逆时针 */CGContextMoveToPoint(contextRef,450,240);CGContextAddLineToPoint(contextRef,400,270);CGContextAddLineToPoint(contextRef,430,310);CGContextMoveToPoint(contextRef,450,240);//设置圆弧的起点CGContextAddArcToPoint(contextRef,400,270,430,310,40);CGContextStrokePath(contextRef);[@&quot;(450,240)&quot; drawInRect:CGRectMake(450, 220, 70, 20) withAttributes:self.attribute];[@&quot;(400,270)&quot; drawInRect:CGRectMake(400 - 70, 270 - 10, 70, 20) withAttributes:self.attribute];[@&quot;(430,310)&quot; drawInRect:CGRectMake(430, 310 + 5, 70, 20) withAttributes:self.attribute];/* 调用CGContextMoveToPoint，设置圆弧的起点。(450,240) CGContextAddArcToPoint(contextRef,400,270,430,310,50):从(450,240)到(400,270)画一条线，再从(400,270)到(430,310)画一条线，两条线和半径(40)确定出一条弧线。弧线对应的圆与两条线相切。 */[@&quot;弧线&quot; drawInRect:CGRectMake(400, 250 + 80 + 20, 40, 20) withAttributes:self.attribute];CGContextSetLineWidth(contextRef, 5);CGContextSetStrokeColorWithColor(contextRef, [UIColor blueColor].CGColor);CGContextMoveToPoint(contextRef, 620, 150);CGContextAddArc(contextRef, 620, 150, 60, -60 * M_PI / 180, -120 * M_PI / 180, 1);CGContextDrawPath(contextRef, kCGPathFill); //绘制路径// CGContextDrawPath(contextRef, kCGPathEOFill);// CGContextDrawPath(contextRef, kCGPathStroke);// CGContextDrawPath(contextRef, kCGPathFillStroke);// CGContextDrawPath(contextRef, kCGPathEOFillStroke);/*CGPathDrawingMode是填充方式,枚举类型 kCGPathFill:只有填充（非零缠绕数填充），不绘制边框 kCGPathEOFill:奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充） kCGPathStroke:只有边框 kCGPathFillStroke：既有边框又有填充 kCGPathEOFillStroke：奇偶填充并绘制边框 */[@&quot;扇形&quot; drawInRect:CGRectMake(600, 60 + 100 + 20, 40, 20) withAttributes:self.attribute];//三角形，添加多个点即可生成多边形CGPoint points[3];//坐标点points[0] = CGPointMake(600,240);//坐标点1points[1] = CGPointMake(600,340);//坐标点2points[2] = CGPointMake(650,340);//坐标点3CGContextAddLines(contextRef, points, 3);//添加线CGContextSetLineWidth(contextRef, 0);CGContextDrawPath(contextRef, kCGPathFillStroke); //根据坐标绘制路径[@&quot;三角形&quot; drawInRect:CGRectMake(600, 340 + 20, 50, 20) withAttributes:self.attribute];CGContextClosePath(contextRef); 代码中有较为详细的注解，这里不再介绍了。 Demogithub.com/hanson1024/Core-Graphics","link":"/test/Quartz-2D.html"},{"title":"LLDB简介 - iOS开发","text":"简介：开发过程中，调试是每个开发者的必备技能。本系列文章主要是围绕苹果公司的LLDB（Lower Level DeBugger 底层调试器）展开介绍。 Lower Level DeBugger 底层调试器LLDB是在LLVM可重用组件构建的下一代高性能调试器，相对于老版本的GDB，LLDB进行了很大的修改升级。其中包括了完整的LLVM编译器。而其中的Clang表达式解析器和反汇编程序就可以使得开发人员可以在控制台直接进行“代码输出“。比如 在打断点以后，在控制器可以进行如下操作： 123456789101112(lldb) po self.view.frame(origin = (x = 0, y = 0), size = (width = 375, height = 667))(lldb) print [self.view.subviews count](NSUInteger) $1 = 0(lldb) print $1 + 9(unsigned long) $2 = 9(lldb) print $2 + 5(unsigned long) $3 = 14(lldb) 要进行在控制台“代码输出”，就要先了解LLDB语法。 LLDB语法在我们的开发过程中与LLDB通过代码交互主要是在调试区域部分输入相应的命令，在每次的输入命令的时候可以有几个命令一起，同时也可以有一个或者几个可选的参数，格式如下： 1&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]] 语法说明： command ：调试命令的名称。 subcommand ：调试子命令的名称，与命令按照层级结构进行构建。一个命令对象为跟其的子命令创建一个上下文，子命令又为其子命令创建一个上下文。如此往复下去，构建整个“命令块”。 action ：执行命令的操作。 options ：option选项，命令选项，动作的修改者；一个命令中可能会有一个或者几个命令选项，可以使用-,--来组合修改执行的动作。 arguement ：命令的参数，一个命令可以有一个或者几个参数，参数的动作执行的额分隔标识。 [] ：标识命令是可选的，可有可无。 上面这些元素都是通过空格来分割，如果元素本身含有空格，则可以使用双引用，如果元素中含有双引号，则可以使用反斜杠或者单引号。 e.g.下面是部分断点(breakpoint)命令，括号中的是规范形式：1234567breakpoint set -M &lt;method&gt; ( --method &lt;method&gt; ) -S &lt;selector&gt; ( --selector &lt;selector&gt; ) -b &lt;function-name&gt; ( --basename &lt;function-name&gt; ) -f &lt;filename&gt; ( --file &lt;filename&gt; ) -l &lt;linenum&gt; ( --line &lt;linenum&gt; ) -n &lt;function-name&gt; ( --name &lt;function-name&gt; ) 具体实例1(lldb) breakpoint set --file ViewController.m --line 38 command : breakpoint 表示断点命令名字 action : set 表示设置断点 options : –file 表示根据方法文件位置设置断点（缩写前面用-，对应上面第5行代码中的-f &lt;filename&gt; ( --file &lt;filename&gt; )） arguement : ViewController.m –line 38 表示文件具体断点位置（ViewController的.m文件第38行） 设置成功之后，控制台会输出：1Breakpoint 2: where = DeBuggerDemo01`-[ViewController doSomethiing] + 35 at ViewController.m:38, address = 0x0000000100a7f683 这样当代码运行到ViewController的.m文件第38行便会暂停。 原始(raw)命令： 原始(raw)命令会将命令后面的所有东西当做参数传递，LLDB支持不带命令选项（option）的原始命令，同时在LLDB中，部分原始命令也是可以带命令选项的（options）。当使用命令选项的时候，需要在命令选项后面加--区分命令选项以及参数。e.g.原始命令expression,分别介绍一下使用--和不使用--的情况 1234(lldb) expression -o selferror: use of undeclared identifier &apos;o&apos;(lldb) expression -o -- self&lt;ViewController: 0x7f86f3f08d00&gt; 唯一匹配原则： 如果根据前面n个字母已经可以唯一匹配到某个命令，则只写前n个字母等效于完整的命令，以下两种输出的效果是一样的。12345(lldb) exp -o -- test50(lldb) expression -o -- test50 命令补全(COMMAND COMPLETION)： 当我们输入一个命令的时候，控制台会自动弹出完整命令，也可以按ESC键手动弹出。 在控制台输入help命令便可以获取每一个命令的使用：代码引用使用 LLDB 调试 APP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 apropos -- 列出与单词或主题相关的调试器命令 breakpoint -- 在断点上操作的命令 (详情使用&apos;help b&apos;查看) bugreport -- 用于创建指定域的错误报告 command -- 用于管理自定义LLDB命令的命令 disassemble -- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数 expression -- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值 frame -- 用于选择和检查当前线程的堆栈帧的命令 gdb-remote -- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost gui -- 切换到基于curses的GUI模式 help -- 显示所有调试器命令的列表，或提供指定命令的详细信息 kdp-remote -- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139 language -- 指定源语言 log -- 控制LLDB内部日志记录的命令 memory -- 用于在当前目标进程的内存上操作的命令 platform -- 用于管理和创建平台的命令 plugin -- 用于管理LLDB插件的命令 process -- 用于与当前平台上的进程交互的命令 quit -- 退出LLDB调试器 register -- 命令访问当前线程和堆栈帧的寄存器 script -- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。 settings -- 用于管理LLDB设置的命令 source -- 检查当前目标进程的调试信息所描述的源代码的命令 target -- 用于在调试器目标上操作的命令 thread -- 用于在当前进程中的一个或多个线程上操作的命令 type -- 在类型系统上操作的命令 version -- 显示LLDB调试器版本 watchpoint -- 在观察点上操作的命令缩写命令 (使用 &apos;help command alias&apos;查看更多信息): add-dsym -- (&apos;target symbols add&apos;) 通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个 attach -- (&apos;_regexp-attach&apos;) 通过ID或名称附加到进程 b -- (&apos;_regexp-break&apos;) 使用几种简写格式之一设置断点 bt -- (&apos;_regexp-bt&apos;) 显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程 c -- (&apos;process continue&apos;) 继续执行当前进程中的所有线程 call -- (&apos;expression --&apos;) 计算当前线程上的表达式,使用LLDB的默认格式显示返回的值 continue -- (&apos;process continue&apos;) 继续执行当前进程中的所有线程 detach -- (&apos;process detach&apos;) 脱离当前目标进程 di -- (&apos;disassemble&apos;) 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数 dis -- (&apos;disassemble&apos;) 同上 display -- (&apos;_regexp-display&apos;) 在每次停止时计算表达式（请参阅&apos;help target stop-hook&apos;） down -- (&apos;_regexp-down&apos;) 选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值 env -- (&apos;_regexp-env&apos;) 查看和设置环境变量的简写 exit -- (&apos;quit&apos;) 退出LLDB调试器 f -- (&apos;frame select&apos;) 从当前线程中通过索引选择当前堆栈帧（参见&apos;thread backtrace&apos;） file -- (&apos;target create&apos;) 使用参数作为主要可执行文件创建目标 finish -- (&apos;thread step-out&apos;) 完成当前堆栈帧的执行并返回后停止。 默认为当前线程 image -- (&apos;target modules&apos;) 用于访问一个或多个目标模块的信息的命令 j -- (&apos;_regexp-jump&apos;) 将程序计数器设置为新地址 jump -- (&apos;_regexp-jump&apos;) 同上 kill -- (&apos;process kill&apos;) 终止当前目标进程 l -- (&apos;_regexp-list&apos;) 使用几种简写格式之一列出相关的源代码 list -- (&apos;_regexp-list&apos;) 同上 n -- (&apos;thread step-over&apos;) 源级单步执行、步进调用，默认当前线程 next -- (&apos;thread step-over&apos;) 同上 nexti -- (&apos;thread step-inst-over&apos;) 指令级单步执行、步进调用，默认当前线程 ni -- (&apos;thread step-inst-over&apos;) 同上 p -- (&apos;expression --&apos;) 计算当前线程上表达式的值，以LLDB默认格式显示返回值 parray -- (&apos;expression -Z %1 --&apos;) 同上 po -- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。 poarray -- (&apos;expression -O -Z %1 --&apos;) 计算当前线程上表达式的值，以LLDB默认格式显示返回值 print -- (&apos;expression --&apos;) 同上 q -- (&apos;quit&apos;) 退出LLDB调试器 r -- (&apos;process launch -X true --&apos;) 在调试器中启动可执行文件 rbreak -- (&apos;breakpoint set -r %1&apos;) 在可执行文件中设置断点或断点集 repl -- (&apos;expression -r -- &apos;) E计算当前线程上表达式的值，以LLDB默认格式显示返回值 run -- (&apos;process launch -X true --&apos;) 在调试器中启动可执行文件 s -- (&apos;thread step-in&apos;) 源级单步执行、步进调用，默认当前线程 si -- (&apos;thread step-inst&apos;) 指令级单步执行、步进调用，默认当前线程 sif -- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止 step -- (&apos;thread step-in&apos;) 源级单步执行、步进调用，默认当前线程 stepi -- (&apos;thread step-inst&apos;) 指令级单步执行、步进调用，默认当前线程 t -- (&apos;thread select&apos;) 更改当前选择的线程 tbreak -- (&apos;_regexp-tbreak&apos;) 使用几种简写格式之一设置单次断点 undisplay -- (&apos;_regexp-undisplay&apos;) 每次停止时停止显示表达式（由stop-hook索引指定） up -- (&apos;_regexp-up&apos;) 选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字 x -- (&apos;memory read&apos;) 从当前目标进程的内存中读取 小结 这篇主要是介绍LLDB，入门篇。接下来还有几篇详细介绍更多的调试技巧。","link":"/test/调试篇-1.html"}],"posts":[{"title":"Jenkins 2018","text":"因为人类偷懒天性，所以当发现繁琐重复的操作，就会想办法简化相应的操作。 在没有Jenkins的时候，我们需要打包给测试同学的操作是这样： 在有Jenkins的时候，我们需要打包给测试同学的操作是这样： 所以我们可以明显看出，后者效率更高，操作更加简便。接下来记录一下，使用Jenkins的过程，给自己做个备忘，也可以提供参考。 准备工作 本次使用的是SVN + Jenkins 进行简便化操作，首先我们去Jenkins官网下载，其中LTS Release（稳定版），Weekly Release（每周更新版本）没有太大的区别，都可以下载。 然后点击下载对应平台的版本。 傻瓜式安装。 完成后，safari会自动打开http://localhost:8080，如果没有可自行输入。这个时候可能会报这个错。 这是因为我们没有配置Java环境，可以点击下载，需要注意一下Java版本，然后傻瓜式安装 我们再次打开http://localhost:8080，如果不行，重启一下。重启后我们会发现，mac新增了一个账号，但是现在我们还不知道密码。用safari打开http://localhost:8080，出现这个页面。表明我们的准备工作正式完成。 配置准备 密码设置我们复制 /Users/Shared/Jenkins/Home，打开Finder，然后Command-Shift-G粘贴刚刚复制的路径。 然后修改sercets文件夹访问权限，右击显示简介，点击右下角的锁。 输入mac密码后，点击权限栏下面。打开initialAdminPassword文件，如果也是没有权限就按照刚刚的一样，修改访问权限。将initialAdminPassword文件中的密码复制到safari中，点击safari中继续 点击左边，跳转到下面 创建用户首先我们需要创建一个管理员用户 创建成功后，点击跳转到欢迎页面 下载插件然后我们安装一些必要的插件 点击系统管理 - 插件管理 - 右上角搜索 安装成功可在系统管理 - 插件管理 - 已安装 中查看 Xcode integration Keychains and Provisioning Profiles Management 配制插件配置插件信息系统管理 - 系统设置 - Xcode Builder 配置插件信息系统管理 - Keychains and Provisioning Profiles Management 创建项目安装完成后我们创建一个项目 配置基本信息 源码管理 构建环境 构建 - General build settings Target为项目中的target名字、 Configuration可以设置发布（Release）或测试（Debug） .ipa filename pattern为 .ipa打包后的文件名 Output directory 为.ipa包目录 构建 - Code signing &amp; OS X keychain options 构建 - Advanced Xcode build options 构建项目 配置信息完成之后，跳转到构建页面 点击立即构建，等待一段时间后可以打包好项目。 后记 “偷懒”是人类发展的“根源”，作为程序员，在编码的工作中，也要时常有这样的思考，优化，重构，封装，才能不断提高等级。","link":"/2018/03/12/Jenkins/"},{"title":"网易严选","text":"个人对网易出品的应用都比较有好感，网易云音乐，网易严选，蜗牛阅读等，用户体验都是比较好的，用“精致”形容不为过。再加上之前公司的项目详情页面采用的就是像素级别仿照。当然现在网易严选的部分版面又有了调整。因为公司最近没有太多事情，所以就用了几天重新仿写了最新版本的网易严选详情页面，像素级别的仿照。 点 页面任意组合布局 商品图片下拉缩放 页面上拉动画，滚动页面 基于UICollectionView换行布局，适用商品多规格选择（服务cell） 继承，分类，Runtime一键添加控件 代码精细化，保证各个类中代码行数 HTML数据抓取 异步，多线程，KVC数据处理 交互与严选保持一致 图 构 待 评论页面跳转 规格数量选择 服务详情弹窗 转发弹窗 Demogithub.com/hanson1024/wangyiyanxuan","link":"/2018/02/20/YANXUAN/"},{"title":"Flutter 初识","text":"西班牙巴塞罗那世界移动大会上，Google发布了第一个beta版的Flutter，前前后后也看了一些视频以及讲解。感觉还是比较靠谱的跨平台，最近自己倒腾了一下，才发现开发原来可以这样来。 Flutter是一个软件开发工具包，可以不过多依赖原系统从而构建高性能，以及高保真的iOS，Android应用程序，在排版布局交互上能够较高的保证用户体验。 我们先来看看几个亮点 跨平台 这个是最主要的亮点，也是Flutter得以发展的根基，无论是开发者，还是老板都希望一个人可以解决前端的所有工作，而不是iOS，Android，前端。当然现在很多再强调大前端，但其实只能说是一个人得需要具备多门技术。而Flutter则只需要一套代码就可以同时运行在两个端，当然有人会提到RN，也是可以完成跨平台，但其构建机制其实是基于原系统的UI进行“封装”，并不能算是完整意义上的跨平台。 相对于nativeApp, webviewApp, React native的区别我们可以看几个对比图 在WebViewApp以及React native均有一个桥接的过程，而在Flutter中使用了Dart语言避免了桥接过程中的性能损耗，从而提升了应用运行的流畅度。 Hot reload 实在是调试一大进步，Android没有开发过，无发言权，但是iOS开发过程中。每次当我们修改一个点，都需要Run一下。而在Hot reload则可以随时修改，在使用Android studio中，只要我们comment + s保存一下，页面就更新了。可以说是非常方便。 此外还有一个进步如下图,当我们需要调试一个类似朋友圈发布的功能： 图中我们可以很明显的看到整个流程的优化。 其他 Flutter框架内置一组丰富控件，可以快速开发UI界面，可定制性强，不受限与OEM控件的限制。 本文主要是进行一些入门的介绍，后续继续添加构建的部分。 参考(科学上网)： 什么是Flutter的革命juejin.im/post/5a38e3f651882527a13d9eb2 flutter.ioflutter.io Two Apps with Flutter and Firebasewww.youtube.com/watch?v=w2TcYP8qiRI&t=1107s 使用 Flutter 快速构建美观的移动应用www.youtube.com/watch?v=9tQUqOwBpy0","link":"/2018/03/28/flutter/"},{"title":"年末2017","text":"回顾17，迎接18年 工作 17年有点类似高产，从16年底到17年底一共完成三款应用的上架，伴随着的是都习惯性的加班，个人的总结少了很多，很多都是业务代码的构写。主要是也是公司的“战略”比较多。 今年是独立开发的开始，项目中的所有都是自己拿主意。有了更多的自由度，也有了更多的尝试。 从湖南到广州，工作环境的变化，个人效率也高了不少。 因为现在招聘好一点基本上会看看你的GitHub，个人博客。不像前几年会拉点控件都可以找到一份不错的工作。世界在进步，只有在浪潮退去之后，才知道谁是裸泳，谁在摸鱼。最近开通了个人博客，也准备把躺在印象笔记里面的东西搬出来，以后也陆续更新一些个人的文章，GitHub里面也准备时常更新一些代码，发现之前空白都是比较多。尴尬。。。 iOS 目前一个项目是采用swift，Objective-C混编，明年3月份有一个新的项目准备全面采用swift，以后主力采用swift。 尝试 小程序也是写了一个Demo就没有下文了，原因也是项目紧，连续几个月的995。。 机器学习，报了优达学院的入门课程，目前还差P3，P4没有完成。感觉有点打水漂了。 因为机器学习需要Python，所以陆陆续续学了一段时间，但是由于项目紧又停了一段时间了。 生活 结束了晚上回家没有人开灯的情况，虽然两个人都加班比较多。。 生活没那么贫乏了 更加有规律，除了晚睡习惯 除了辣椒，其他东西也有好吃的 身边的长辈都老了，到了该享乐的年纪，却没有享乐的条件 物质条件更加好了，却越来越忙 最后 工作方面，需要更多的总结，时常更新内容，向高级开发进军。 生活方面，保重身体。 2018 提高iOS开发能力 Flutter, react-native, Weex 小程序 开源一个到两个swift框架 上架一个iOS应用","link":"/2017/12/30/年末2017/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"效率","slug":"效率","link":"/tags/效率/"},{"name":"网易","slug":"网易","link":"/tags/网易/"},{"name":"模仿","slug":"模仿","link":"/tags/模仿/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"跨平台","slug":"跨平台","link":"/tags/跨平台/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"工作","slug":"工作","link":"/tags/工作/"}],"categories":[{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"模仿","slug":"模仿","link":"/categories/模仿/"},{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"生活","slug":"生活","link":"/categories/生活/"}]}