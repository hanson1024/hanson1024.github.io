<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="IM构建 01 网络基础建设"/>




  <meta name="keywords" content="IM,socket," />





  <link rel="alternate" href="/atom.xml" title="sqjuanke">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://yoursite.com/2019/11/26/im-01/"/>


<meta name="description" content="socket基本知识 socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址 创建socket连接时，可以配置不同传输协议，支持TCP/UDP 在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息 上面一点需要注">
<meta name="keywords" content="IM,socket">
<meta property="og:type" content="article">
<meta property="og:title" content="IM构建 01 网络基础建设">
<meta property="og:url" content="http://yoursite.com/2019/11/26/im-01/index.html">
<meta property="og:site_name" content="sqjuanke">
<meta property="og:description" content="socket基本知识 socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址 创建socket连接时，可以配置不同传输协议，支持TCP/UDP 在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息 上面一点需要注">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcYgENEyfYmnejfrOnSCPSq2u5ywusHSU7o2Oa0iLmK7cD32gz4e5m09rgY*6IfwtXTPLmw*RaVKUDKvVLR5aKJk!/r">
<meta property="og:updated_time" content="2020-11-26T08:11:55.215Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IM构建 01 网络基础建设">
<meta name="twitter:description" content="socket基本知识 socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址 创建socket连接时，可以配置不同传输协议，支持TCP/UDP 在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息 上面一点需要注">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcYgENEyfYmnejfrOnSCPSq2u5ywusHSU7o2Oa0iLmK7cD32gz4e5m09rgY*6IfwtXTPLmw*RaVKUDKvVLR5aKJk!/r">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> IM构建 01 网络基础建设 - sqjuanke </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">sqjuanke</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          IM构建 01 网络基础建设
        
      </h1>

      <time class="post-time">
          11月 26 2019
      </time>
    </header>



    
            <div class="post-content">
            <h1 id="socket基本知识"><a href="#socket基本知识" class="headerlink" title="socket基本知识"></a>socket基本知识</h1><ul>
<li>socket并非协议，是一种编程接口。在建立连接过程中，需要端口号，IP地址</li>
<li>创建socket连接时，可以配置不同传输协议，支持TCP/UDP</li>
<li>在基于TCP连接时，如果socket连接建立后，两个端（客户端/服务器端）便可以进行通信，区别于HTTP，socket连接中，服务器端可以主动给客户端发送消息，而且无需每次都进行连接，只要连接没有断开，可以持续发送消息</li>
<li>上面一点需要注意，尽管一旦建立连接后可以持续发送消息，但是在实际情况下，有多种因素导致断开，比如网关，防火墙等等因素，所以需要借助心跳包，来“监听”网络是否断开</li>
<li>使用Socket无需设置ATS</li>
</ul>
<a id="more"></a>
<p>socket流程图：</p>
<p><img src="http://r.photo.store.qq.com/psc?/V12iUFxG1GOso0/45NBuzDIW489QBoVep5mcYgENEyfYmnejfrOnSCPSq2u5ywusHSU7o2Oa0iLmK7cD32gz4e5m09rgY*6IfwtXTPLmw*RaVKUDKvVLR5aKJk!/r" alt=""></p>
<h2 id="1、GCD控制网络调用"><a href="#1、GCD控制网络调用" class="headerlink" title="1、GCD控制网络调用"></a>1、GCD控制网络调用</h2><p>使用GCD控制连接、心跳包的操作，只需要dispatch_suspend即可停止操作</p>
<ul>
<li>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，因网关、防火墙等导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init &#123;</span><br><span class="line"></span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">        self.connectTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">        dispatch_source_set_event_handler(self.connectTimer, ^&#123;</span><br><span class="line">            //进行连接</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        self.heartbeatTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">        dispatch_source_set_event_handler(self.heartbeatTimer, ^&#123;</span><br><span class="line">            //心跳包发送</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>发起连接操作：对于连接操作，无需重复操作，对于心跳则使用延后，定时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t w = dispatch_walltime(NULL, 0);</span><br><span class="line">dispatch_source_set_timer(self.connectTimer, w, DISPATCH_TIME_FOREVER, 0);</span><br><span class="line">dispatch_resume(self.connectTimer);</span><br><span class="line">    </span><br><span class="line">w = dispatch_walltime(NULL, self.heartTime);</span><br><span class="line">dispatch_source_set_timer(self.heartTime, w, self.heartTime*NSEC_PER_SEC, self.heartTime*NSEC_PER_SEC/2);</span><br><span class="line">dispatch_resume(self.heartbeatTimer);</span><br></pre></td></tr></table></figure>
<h2 id="2、连接过程"><a href="#2、连接过程" class="headerlink" title="2、连接过程"></a>2、连接过程</h2><p>基于socket连接，设置SQTCP实例类</p>
<p><strong>addrinfo 结构体</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct addrinfo &#123;</span><br><span class="line">    int ai_flags;        </span><br><span class="line">    int ai_family;        </span><br><span class="line">    int ai_socktype;    </span><br><span class="line">    int ai_protocol;                </span><br><span class="line">    size_t ai_addrlen;              //指向缓冲区的字节数</span><br><span class="line">    char* ai_canonname;             //主机的规范化名称</span><br><span class="line">    struct sockaddr* ai_addr;       //指向sockaddr结构的指针。getaddrinfo返回的每个addrinfo结构内的ai_addr都指向一个filled-in套接字地址结构。</span><br><span class="line">    struct addrinfo* ai_next;       //指向链表中下一个addrinfo结构的指针，如果是链表的最后一个addrinfo结构，则ai_next为NULL。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ai_family</td>
<td>AF_INET</td>
<td>2</td>
<td>IPv4</td>
</tr>
<tr>
<td></td>
<td>AF_INET6</td>
<td>23</td>
<td>IPv6</td>
</tr>
<tr>
<td></td>
<td>AF_UNSPEC</td>
<td>0</td>
<td>协议无关</td>
</tr>
<tr>
<td>ai_protocol</td>
<td>IPPROTO_IP</td>
<td>0</td>
<td>IP协议</td>
</tr>
<tr>
<td></td>
<td>IPPROTO_IPV4</td>
<td>4</td>
<td>IPv4</td>
</tr>
<tr>
<td></td>
<td>IPPROTO_IPV6</td>
<td>41</td>
<td>IPv6</td>
</tr>
<tr>
<td></td>
<td>IPPROTO_UDP</td>
<td>17</td>
<td>UDP</td>
</tr>
<tr>
<td></td>
<td>IPPROTO_TCP</td>
<td>6</td>
<td>TCP</td>
</tr>
<tr>
<td>ai_socktype</td>
<td>SOCK_STREAM</td>
<td>1</td>
<td>流 (默认协议是TCP)</td>
</tr>
<tr>
<td></td>
<td>SOCK_DGRAM</td>
<td>2</td>
<td>数据报(默认协议是UDP)</td>
</tr>
<tr>
<td>ai_flags</td>
<td>AI_PASSIVE</td>
<td>1</td>
<td>被动的，用于bind，通常用于server socket</td>
</tr>
<tr>
<td></td>
<td>AI_CANONNAME</td>
<td>2</td>
<td>IPv4</td>
</tr>
<tr>
<td></td>
<td>AI_NUMERICHOST</td>
<td>4</td>
<td>地址为数字串</td>
</tr>
</tbody>
</table>
<p>ai_flags 说明：<br>ai_flags的值范围为0~7，取决于程序如何设置3个标志位，比如设置ai_flags为 “AI_PASSIVE|AI_CANONNAME”，ai_flags值就为3。三个参数的含义分别为：</p>
<ul>
<li>AI_PASSIVE当此标志置位时，表示调用者将在bind()函数调用中使用返回的地址结构。当此标志不置位时，表示将在connect()函数调用中使用。当节点名位NULL，且此标志置位，则返回的地址将是通配地址。如果节点名NULL，且此标志不置位，则返回的地址将是回环地址。</li>
<li>AI_CANNONAME当此标志置位时，在函数所返回的第一个addrinfo结构中的ai_cannoname成员中，应该包含一个以空字符结尾的字符串，字符串的内容是节点名的正规名。</li>
<li>AI_NUMERICHOST当此标志置位时，此标志表示调用中的节点名必须是一个数字地址字符串。</li>
</ul>
<p><strong>getaddrinfo 函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result )</span><br></pre></td></tr></table></figure></p>
<p>getaddrinfo：函数能够处理名字到地址以及服务到端口这两种转换，返回的是一个sockaddr 结构的链而不是一个地址清单。它具有协议无关性。</p>
<ul>
<li>hostname:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)</li>
<li>service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等</li>
<li>hints：可以是一个空指针，也可以是一个指向某个addrinfo结构的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。</li>
<li>返回0： 成功，返回非0： 出错。</li>
</ul>
<p><strong>connect</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)connect:(NSString*)host port:(int)port completionBlock:(SQConnectCompletionBlock)completionBlock &#123;</span><br><span class="line">    </span><br><span class="line">    struct sockaddr_in6 addr;</span><br><span class="line">    struct addrinfo addrinfo;</span><br><span class="line">    </span><br><span class="line">    BOOL res = [self _synthesizeIPv6:host port:port addr:(struct sockaddr*)&amp;addr addrinfo:&amp;addrinfo];</span><br><span class="line">    if (!res) &#123;</span><br><span class="line">        NSLog(@&quot;synthesize ipv6 fail&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int r;</span><br><span class="line">    int sockfd;</span><br><span class="line">    </span><br><span class="line">    // socket()函数用于根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所用的资源。如果协议protocol未指定(等于0), 则使用缺省的连接方式。</span><br><span class="line">    sockfd = socket(addrinfo.ai_family, addrinfo.ai_socktype, addrinfo.ai_protocol);</span><br><span class="line">    sock_nonblock(sockfd, 1);</span><br><span class="line">    </span><br><span class="line">    int value = 1;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &amp;value, sizeof(value));</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (addrinfo.ai_family == AF_INET) &#123;</span><br><span class="line">        </span><br><span class="line">            // 用于建立与指定socket的连接.</span><br><span class="line">            // 客户端socket</span><br><span class="line">            // 指向数据结构sockaddr的指针，其中包括目的端口和IP地址服务器的&quot;结构体&quot;地址</span><br><span class="line">            // 结构体数据长度</span><br><span class="line">    </span><br><span class="line">            r = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(struct sockaddr_in));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //ipv6</span><br><span class="line">            r = connect(sockfd, (struct sockaddr*)&amp;addr, sizeof(struct sockaddr_in6));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (r == -1 &amp;&amp; errno == EINTR);</span><br><span class="line">    if (r == -1) &#123;</span><br><span class="line">        if (errno != EINPROGRESS) &#123;</span><br><span class="line">            close(sockfd);</span><br><span class="line">            NSLog(@&quot;connect error:%s&quot;, strerror(errno));</span><br><span class="line">            return FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    self.writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, sockfd, 0, queue);</span><br><span class="line">    __weak SQTCP *wself = self;</span><br><span class="line">    dispatch_source_set_event_handler(self.writeSource, ^&#123;</span><br><span class="line">        [wself _onWrite];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_resume(self.writeSource);</span><br><span class="line">    self.sock = sockfd;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)_synthesizeIPv6:(NSString*)host port:(int)port addr:(struct sockaddr*)addr addrinfo:(struct addrinfo*)info &#123;</span><br><span class="line">    int error;</span><br><span class="line">    struct addrinfo hints, *res0, *res;</span><br><span class="line">    const char *ipv4_str = [host UTF8String];</span><br><span class="line">    </span><br><span class="line">    memset(&amp;hints, 0, sizeof(hints));</span><br><span class="line">    hints.ai_family = PF_UNSPEC;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_DEFAULT;</span><br><span class="line">    </span><br><span class="line">    error = getaddrinfo(ipv4_str, &quot;&quot;, &amp;hints, &amp;res0);</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;, gai_strerror(error));</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (res = res0; res; res = res-&gt;ai_next) &#123;</span><br><span class="line">        NSLog(@&quot;family:%d socktype;%d protocol:%d&quot;, res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BOOL r = YES;</span><br><span class="line"></span><br><span class="line">    if (res0) &#123;</span><br><span class="line">        if (res0-&gt;ai_family == AF_INET6) &#123;</span><br><span class="line">            struct sockaddr_in6 *addr6 = ((struct sockaddr_in6*)res0-&gt;ai_addr);</span><br><span class="line">            addr6-&gt;sin6_port = htons(port);</span><br><span class="line">            </span><br><span class="line">            memcpy(addr, res0-&gt;ai_addr, res0-&gt;ai_addrlen);</span><br><span class="line">            *info = *res0;</span><br><span class="line">        &#125; else if (res0-&gt;ai_family == AF_INET) &#123;</span><br><span class="line">            struct sockaddr_in *addr4 = ((struct sockaddr_in*)res0-&gt;ai_addr);</span><br><span class="line">            addr4-&gt;sin_port = htons(port);</span><br><span class="line">            </span><br><span class="line">            memcpy(addr, res0-&gt;ai_addr, res0-&gt;ai_addrlen);</span><br><span class="line">            *info = *res0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(res0);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>write</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)write:(NSData*)data &#123;</span><br><span class="line">    [self.data appendData:data];</span><br><span class="line">    if (!self.writeSourceActive &amp;&amp; self.writeSource) &#123;</span><br><span class="line">        dispatch_resume(self.writeSource);</span><br><span class="line">        self.writeSourceActive = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)_onWrite &#123;</span><br><span class="line">    </span><br><span class="line">    const char *p = [self.data bytes];</span><br><span class="line">    int n = write_data(self.sock, (uint8_t*)p, (int)self.data.length);</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        NSLog(@&quot;sock write error:%d&quot;, errno);</span><br><span class="line">        dispatch_suspend(self.writeSource);</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.data = [NSMutableData dataWithBytes:p+n length:self.data.length - n];</span><br><span class="line">    if (self.data.length == 0) &#123;</span><br><span class="line">        dispatch_suspend(self.writeSource);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int write_data(int fd, uint8_t *bytes, int len) &#123;</span><br><span class="line">    ssize_t n = 0;</span><br><span class="line">     </span><br><span class="line">    do &#123;</span><br><span class="line">    </span><br><span class="line">     // 客户端socket</span><br><span class="line">     // 发送内容地址 void * == id</span><br><span class="line">     // 发送内容长度</span><br><span class="line">     // 发送方式标志，一般为0</span><br><span class="line">    </span><br><span class="line">        n = send(fd, bytes, len, 0);</span><br><span class="line">    &#125; while(n == -1 &amp;&amp; errno == EINTR);</span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        if (errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (int)n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>read</strong></p>
<ul>
<li>服务器返回的数据不一定会一次全部返完，所以我们需要循环接收数据，当返回数据为0时结束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-(void)startRead:(SQReadCompletionBlock)completionBlock &#123;</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    self.readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, self.sock, 0, queue);</span><br><span class="line">    __weak SQTCP *wself = self;</span><br><span class="line">    dispatch_source_set_event_handler(self.readSource, ^&#123;</span><br><span class="line">        [wself onRead];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(self.readSource);</span><br><span class="line">    self.readSourceActive = YES;</span><br><span class="line">    self.readCompletionBlock = completionBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-(void)onRead &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        ssize_t nread;</span><br><span class="line">        char buf[BUF_SIZE];</span><br><span class="line">        </span><br><span class="line">        do &#123;</span><br><span class="line">        </span><br><span class="line">        // 客户端socket</span><br><span class="line">        // 接收内容缓冲区地址</span><br><span class="line">        // 接收内容缓存区长度</span><br><span class="line">        </span><br><span class="line">            nread = read(self.sock, buf, BUF_SIZE);</span><br><span class="line">        &#125;while (nread &lt; 0 &amp;&amp; errno == EINTR);</span><br><span class="line">        </span><br><span class="line">        if (nread &lt; 0) &#123;</span><br><span class="line">            if (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self.readCompletionBlock(self, nil, errno);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (nread == 0) &#123;</span><br><span class="line">            self.readCompletionBlock(self, nil, 0);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSData *data = [NSData dataWithBytes:buf length:nread];</span><br><span class="line">            self.readCompletionBlock(self, data, 0);</span><br><span class="line">            if (nread &lt; BUF_SIZE) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>close</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-(void)close &#123;</span><br><span class="line">    __block int count = 0;</span><br><span class="line">    </span><br><span class="line">    void (^on_cancel)() = ^&#123;</span><br><span class="line">        --count;</span><br><span class="line">        if (count == 0) &#123;</span><br><span class="line">            NSLog(@&quot;async tcp closed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    if (self.writeSource) count++;</span><br><span class="line">    if (self.readSource) count++;</span><br><span class="line">    if (self.writeSource) &#123;</span><br><span class="line">        NSLog(@&quot;cancel write source&quot;);</span><br><span class="line">        if (!self.writeSourceActive) &#123;</span><br><span class="line">            dispatch_resume(self.writeSource);</span><br><span class="line">            self.writeSourceActive = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_source_set_cancel_handler(self.writeSource, on_cancel);</span><br><span class="line">        dispatch_source_cancel(self.writeSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.readSource) &#123;</span><br><span class="line">        NSLog(@&quot;cancel read source&quot;);</span><br><span class="line">        if (!self.readSourceActive) &#123;</span><br><span class="line">            dispatch_resume(self.readSource);</span><br><span class="line">            self.readSourceActive = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_source_set_cancel_handler(self.readSource, on_cancel);</span><br><span class="line">        dispatch_source_cancel(self.readSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.sock != -1) &#123;</span><br><span class="line">        NSLog(@&quot;close socket&quot;);</span><br><span class="line">        close(self.sock);</span><br><span class="line">        self.sock = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/IM/">IM</a>
		  
			<a href="/tags/socket/">socket</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2018/10/29/tutorial-for-ios-getting-started-with-opengl-es-02/">
        <span class="next-text nav-default">OpenGL ES2.0 – iphone开发指引 下</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2020
    <span class="footer-author">luo.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
